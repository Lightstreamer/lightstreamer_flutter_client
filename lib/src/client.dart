import 'dart:io';
import 'dart:async';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;
import 'package:lightstreamer_flutter_client/src/client_listeners.dart';
import 'package:lightstreamer_flutter_client/src/log_manager.dart';
import 'package:lightstreamer_flutter_client/src/logger.dart';
import 'package:lightstreamer_flutter_client/src/utils.dart';

part 'native_bridge.dart';
part 'item_update.dart';

/**
 * Facade class for the management of the communication to
 * Lightstreamer Server. 
 * 
 * Used to provide configuration settings, event
 * handlers, operations for the control of the connection lifecycle,
 * [Subscription] handling and to send messages. <BR>
 * It also provides support for mobile push notifications (MPN) via
 * [MpnSubscription], a specific kind of subscription that
 * routes real-time updates via push notifications. <BR>
 * An instance of LightstreamerClient handles the communication with
 * Lightstreamer Server on a specified endpoint. Hence, it hosts one "Session";
 * or, more precisely, a sequence of Sessions, since any Session may fail
 * and be recovered, or it can be interrupted on purpose.
 * So, normally, a single instance of LightstreamerClient is needed. <BR>
 * However, multiple instances of LightstreamerClient can be used,
 * toward the same or multiple endpoints.
 * 
 * You can listen to the events generated by a session by registering an event listener, such as [ClientListener] or [SubscriptionListener]. 
 * These listeners allow you to handle various events, such as session creation, connection status, subscription updates, and server messages. 
 * However, you should be aware that the event notifications are dispatched by a single thread, the so-called event thread. 
 * This means that if the operations of a listener are slow or blocking, they will delay the processing of the other listeners and 
 * affect the performance of your application. 
 * Therefore, you should delegate any slow or blocking operations to a dedicated thread, and keep the listener methods as fast and simple as possible.
 * Note that even if you create multiple instances of LightstreamerClient, they will all use a single event thread, that is shared among them.
 */
class LightstreamerClient {
  static int _idGenerator = 0;

  late final String _id;
  /**
   * Data object that contains the details needed to open a connection to 
   * a Lightstreamer Server. 
   * 
   * This instance is set up by the LightstreamerClient object at 
   * its own creation. <BR>
   * Properties of this object can be overwritten by values received from a 
   * Lightstreamer Server. 
   */
  late final ConnectionDetails connectionDetails;
  /**
   * Data object that contains options and policies for the connection to 
   * the server. 
   * 
   * This instance is set up by the LightstreamerClient object at 
   * its own creation. <BR>
   * Properties of this object can be overwritten by values received from a 
   * Lightstreamer Server. 
   */
  late final ConnectionOptions connectionOptions;
  final List<ClientListener> _listeners = [];

  /**
   * Creates an object to be configured to connect to a Lightstreamer server
   * and to handle all the communications with it.
   * 
   * Each LightstreamerClient is the entry point to connect to a Lightstreamer server, 
   * subscribe to as many items as needed and to send messages. 
   * 
   * - [serverAddress] the address of the Lightstreamer Server to
   * which this LightstreamerClient will connect to. It is possible to specify it later
   * by using null here. See [ConnectionDetails.setServerAddress] 
   * for details.
   * - [adapterSet] the name of the Adapter Set mounted on Lightstreamer Server 
   * to be used to handle all requests in the Session associated with this 
   * LightstreamerClient. It is possible not to specify it at all or to specify 
   * it later by using null here. See [ConnectionDetails.setAdapterSet] 
   * for details.
   *
   * **Throws** IllegalArgumentException if a not valid address is passed. See
   * [ConnectionDetails.setServerAddress] for details.
   */
  LightstreamerClient(String? serverAddress, String? adapterSet) : _id = '${_idGenerator++}' {
    connectionDetails = ConnectionDetails._(_id);
    connectionOptions = ConnectionOptions._(_id);
    connectionDetails._serverAddress = serverAddress;
    connectionDetails._adapterSet = adapterSet;
    NativeBridge.instance.client_create(_id, this);
  }

  /// @nodoc
  /// Removes from the internal maps the library objects (LightstreamerClients, Subscriptions etc.) that are inaccessible (i.e. eligible to be garbage collected).
  /// This method is automatically called when `subscribe` or `subscribeMpn` are invoked.
  ///
  /// Rationale:
  /// The internal maps are of type MyWeakMap, which holds values in weak references.
  /// Periodically, these maps must be cleaned to remove cleared weak references.
  /// Since `subscribe` and `subscribeMpn` are the most frequently used methods, it makes sense to perform the cleaning when they are invoked.
  @visibleForTesting
  static Future<void> cleanResources() {
    return NativeBridge.instance.cleanResources();
  }

  /**
   * Static method that permits to configure the logging system used by the library. 
   * 
   * The logging system must respect the [LoggerProvider] 
   * interface. A custom class can be used to wrap any third-party 
   * Java logging system. <BR>
   * If no logging system is specified, all the generated log is discarded. <BR>
   * The following categories are available to be consumed:
   * <ul>
   *  <li>lightstreamer.stream:<BR>
   *  logs socket activity on Lightstreamer Server connections;<BR>
   *  at INFO level, socket operations are logged;<BR>
   *  at DEBUG level, read/write data exchange is logged.
   *  </li>
   *  <li>lightstreamer.protocol:<BR>
   *  logs requests to Lightstreamer Server and Server answers;<BR>
   *  at INFO level, requests are logged;<BR>
   *  at DEBUG level, request details and events from the Server are logged.
   *  <li>lightstreamer.session:<BR>
   *  logs Server Session lifecycle events;<BR>
   *  at INFO level, lifecycle events are logged;<BR>
   *  at DEBUG level, lifecycle event details are logged.
   *  </li>
   *  <li>lightstreamer.subscriptions:<BR>
   *  logs subscription requests received by the clients and the related updates;<BR>
   *  at WARN level, alert events from the Server are logged;<BR>
   *  at INFO level, subscriptions and unsubscriptions are logged;<BR>
   *  at DEBUG level, requests batching and update details are logged.
   *  </li>
   *  <li>lightstreamer.actions:<BR>
   *  logs settings / API calls.
   *  </li>
   * </ul>
   *
   * - [provider] A [LoggerProvider] instance that will be used to generate log messages by the library classes.
   */
  static Future<void> setLoggerProvider(LoggerProvider provider) async {
    var logger = provider.getLogger('lightstreamer');
    var level = logger.isDebugEnabled() ? ConsoleLogLevel.DEBUG
              : logger.isErrorEnabled() ? ConsoleLogLevel.ERROR
              : logger.isWarnEnabled()  ? ConsoleLogLevel.WARN
              : logger.isInfoEnabled()  ? ConsoleLogLevel.INFO
              : logger.isFatalEnabled() ? ConsoleLogLevel.FATAL
              : ConsoleLogLevel.TRACE;
    var arguments = <String, dynamic>{
      'level': level
    };
    LogManager.setLoggerProvider(provider);
    return await NativeBridge.instance.invokeMethod('LightstreamerClient.setLoggerProvider', arguments);
  }

  /**
   * Static method that can be used to share cookies between connections to the Server
   * (performed by this library) and connections to other sites that are performed
   * by the application. 
   * 
   * With this method, cookies received by the application
   * can be added (or replaced if already present) to the cookie set used by the
   * library to access the Server. Obviously, only cookies whose domain is compatible
   * with the Server domain will be used internally.
   * 
   * **Lifecycle** This method should be invoked before calling the
   * [LightstreamerClient.connect] method. However it can be invoked at any time;
   * it will affect the internal cookie set immediately and the sending of cookies
   * on the next HTTP request or WebSocket establishment.
   * 
   * - [uri] the URI from which the supplied cookies were received. It cannot be null.
   * 
   * - [cookies] a list of cookies.
   * 
   * - See [getCookies]
   */
  static Future<void> addCookies(String uri, List<Cookie> cookies) async {
    var arguments = <String, dynamic>{
      'uri': uri,
      'cookies': cookies.map((e) => e.toString()).toList()
    };
    return await NativeBridge.instance.invokeMethod('LightstreamerClient.addCookies', arguments);
  }

  /**  
   * Static inquiry method that can be used to share cookies between connections to the Server
   * (performed by this library) and connections to other sites that are performed
   * by the application. 
   * 
   * With this method, cookies received from the Server can be
   * extracted for sending through other connections, according with the URI to be accessed.
   * <BR>See [addCookies] for clarifications on when cookies are directly stored
   * by the library and when not.
   *
   * - [uri] the URI to which the cookies should be sent.
   * 
   * **Returns** an immutable list with the various cookies that can
   * be sent in a HTTP request for the specified URI.
   */
  static Future<List<Cookie>> getCookies(String uri) async {
    var arguments = <String, dynamic>{
      'uri': uri
    };
    List<String> cookies = (await NativeBridge.instance.invokeMethod('LightstreamerClient.getCookies', arguments)).cast<String>();
    return cookies.map((e) => Cookie.fromSetCookieValue(e)).toList();
  }

  /**
   * Operation method that requests to open a Session against the configured Lightstreamer Server.
   * 
   * When connect() is called, unless a single transport was forced through 
   * [ConnectionOptions.setForcedTransport], the so called "Stream-Sense" mechanism is started: 
   * if the client does not receive any answer for some seconds from the streaming connection, then it 
   * will automatically open a polling connection. <BR>
   * A polling connection may also be opened if the environment is not suitable for a streaming connection. <BR>
   * Note that as "polling connection" we mean a loop of polling requests, each of which requires opening a 
   * synchronous (i.e. not streaming) connection to Lightstreamer Server.
   * 
   * **Lifecycle** Note that the request to connect is accomplished by the client in a separate thread; this means 
   * that an invocation to [getStatus] right after connect() might not reflect the change yet. <BR> 
   * When the request to connect is finally being executed, if the current status
   * of the client is not DISCONNECTED, then nothing will be done.
   * 
   * **Throws** IllegalStateException if no server address was configured.
   * 
   * - See [getStatus]
   * - See [disconnect]
   * - See [ClientListener.onStatusChange]
   * - See [ConnectionDetails.setServerAddress]
   */
  Future<void> connect() async {
    var arguments = <String, dynamic>{
      "connectionDetails": connectionDetails._toMap(),
      "connectionOptions": connectionOptions._toMap(),
    };
    return await _invokeMethod('connect', arguments);
  }

  /**
   * Operation method that requests to close the Session opened against the configured Lightstreamer Server (if any).
   * 
   * When disconnect() is called, the "Stream-Sense" mechanism is stopped. <BR>
   * Note that active Subscription instances, associated with this LightstreamerClient instance, are preserved 
   * to be re-subscribed to on future Sessions.
   * 
   * **Lifecycle**  Note that the request to disconnect is accomplished by the client in a separate thread; this 
   * means that an invocation to [getStatus] right after disconnect() might not reflect the change yet. <BR> 
   * When the request to disconnect is finally being executed, if the status of the client is "DISCONNECTED", 
   * then nothing will be done.
   * 
   * - See [connect]
   */
  Future<void> disconnect() async {
    return await _invokeMethod('disconnect');
  }

  /**
   * Inquiry method that gets the current client status and transport (when applicable).
   * 
   * **Returns** The current client status. It can be one of the following values:
   * <ul>
   *  <li>"CONNECTING" the client is waiting for a Server's response in order to establish a connection;</li>
   *  <li>"CONNECTED:STREAM-SENSING" the client has received a preliminary response from the server and 
   *  is currently verifying if a streaming connection is possible;</li>
   *  <li>"CONNECTED:WS-STREAMING" a streaming connection over WebSocket is active;</li>
   *  <li>"CONNECTED:HTTP-STREAMING" a streaming connection over HTTP is active;</li>
   *  <li>"CONNECTED:WS-POLLING" a polling connection over WebSocket is in progress;</li>
   *  <li>"CONNECTED:HTTP-POLLING" a polling connection over HTTP is in progress;</li>
   *  <li>"STALLED" the Server has not been sending data on an active streaming connection for longer 
   *  than a configured time;</li>
   *  <li>"DISCONNECTED:WILL-RETRY" no connection is currently active but one will be opened (possibly after a timeout);</li>
   *  <li>"DISCONNECTED:TRYING-RECOVERY" no connection is currently active,
   *  but one will be opened as soon as possible, as an attempt to recover
   *  the current session after a connection issue;</li> 
   *  <li>"DISCONNECTED" no connection is currently active.</li>
   * </ul>
   * 
   * - See [ClientListener.onStatusChange]
   */
  Future<String> getStatus() async {
    return await _invokeMethod('getStatus');
  }

  /**
   * Operation method that adds a Subscription to the list of "active" Subscriptions. The Subscription cannot already be in the "active" state.
   * 
   * Active subscriptions are subscribed to through the server as soon as possible (i.e. as soon as there is a 
   * session available). Active Subscription are automatically persisted across different sessions as long as a 
   * related unsubscribe call is not issued.
   * 
   * **Lifecycle** Subscriptions can be given to the LightstreamerClient at any time. Once done the Subscription 
   * immediately enters the "active" state. <BR>
   * Once "active", a Subscription instance cannot be provided again to a LightstreamerClient unless it is 
   * first removed from the "active" state through a call to [unsubscribe]. <BR>
   * Also note that forwarding of the subscription to the server is made in a separate thread. <BR>
   * A successful subscription to the server will be notified through a [SubscriptionListener.onSubscription]
   * event.
   * 
   * - [sub] A Subscription object, carrying all the information needed to process real-time values.
   * 
   * - See [unsubscribe]
   */
  Future<void> subscribe(Subscription sub) async {
    var arguments = <String, dynamic>{
      'subscription': sub._toMap()
    };
    sub._active = true;
    await NativeBridge.instance.client_subscribe(_id, sub._id, sub, arguments);
    // NB _remoteActive is set after the remote call to ensure that, when the call returns,
    // the remote image of the local subscription has been created
    sub._remoteActive = true;
    //
    cleanResources(); // no need to await here
  }

  /**
   * Operation method that removes a Subscription that is currently in the "active" state.
   *  
   * By bringing back a Subscription to the "inactive" state, the unsubscription from all its items is 
   * requested to Lightstreamer Server.
   * 
   * **Lifecycle** Subscription can be unsubscribed from at any time. Once done the Subscription immediately 
   * exits the "active" state. <BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread. <BR>
   * The unsubscription will be notified through a [SubscriptionListener.onUnsubscription] event.
   * 
   * - [sub] An "active" Subscription object that was activated by this LightstreamerClient 
   * instance.
   */
  Future<void> unsubscribe(Subscription sub) async {
    var arguments = <String, dynamic>{
      'subId': sub._id
    };
    sub._active = false;
    sub._subscribed = false;
    sub._commandPosition = null;
    sub._keyPosition = null;
    return await NativeBridge.instance.client_unsubscribe(_id, sub._id, arguments);
  }

  /**
   * Inquiry method that returns a list containing all the Subscription instances that are 
   * currently "active" on this LightstreamerClient.
   * 
   * Internal second-level Subscription are not included.
   *
   * **Returns** A list, containing all the Subscription currently "active" on this LightstreamerClient. <BR>
   * The list can be empty.
   * - See [subscribe]
   */
  Future<List<Subscription>> getSubscriptions() async {
    return await NativeBridge.instance.client_getSubscriptions(_id);
  }

  /**
   * Operation method that sends a message to the Server. 
   * 
   * The message is interpreted and handled by 
   * the Metadata Adapter associated to the current Session. This operation supports in-order 
   * guaranteed message delivery with automatic batching. In other words, messages are guaranteed 
   * to arrive exactly once and respecting the original order, whatever is the underlying transport 
   * (HTTP or WebSockets). Furthermore, high frequency messages are automatically batched, if necessary,
   * to reduce network round trips. <BR>
   * Upon subsequent calls to the method, the sequential management of the involved messages is guaranteed. 
   * The ordering is determined by the order in which the calls to sendMessage are issued. <BR>
   * If a message, for any reason, doesn't reach the Server (this is possible with the HTTP transport),
   * it will be resent; however, this may cause the subsequent messages to be delayed.
   * For this reason, each message can specify a "delayTimeout", which is the longest time the message, after
   * reaching the Server, can be kept waiting if one of more preceding messages haven't been received yet.
   * If the "delayTimeout" expires, these preceding messages will be discarded; any discarded message
   * will be notified to the listener through [ClientMessageListener.onDiscarded].
   * Note that, because of the parallel transport of the messages, if a zero or very low timeout is 
   * set for a message and the previous message was sent immediately before, it is possible that the
   * latter gets discarded even if no communication issues occur.
   * The Server may also enforce its own timeout on missing messages, to prevent keeping the subsequent
   * messages for long time. <BR>
   * Sequence identifiers can also be associated with the messages. In this case, the sequential management is 
   * restricted to all subsets of messages with the same sequence identifier associated. <BR>
   * Notifications of the operation outcome can be received by supplying a suitable listener. The supplied 
   * listener is guaranteed to be eventually invoked; listeners associated with a sequence are guaranteed 
   * to be invoked sequentially. <BR>
   * The "UNORDERED_MESSAGES" sequence name has a special meaning. For such a sequence, immediate processing 
   * is guaranteed, while strict ordering and even sequentialization of the processing is not enforced. 
   * Likewise, strict ordering of the notifications is not enforced. However, messages that, for any reason, 
   * should fail to reach the Server whereas subsequent messages had succeeded, might still be discarded after 
   * a server-side timeout, in order to ensure that the listener eventually gets a notification.<BR>
   * Moreover, if "UNORDERED_MESSAGES" is used and no listener is supplied, a "fire and forget" scenario
   * is assumed. In this case, no checks on missing, duplicated or overtaken messages are performed at all,
   * so as to optimize the processing and allow the highest possible throughput.
   * 
   * **Lifecycle** Since a message is handled by the Metadata Adapter associated to the current connection, a
   * message can be sent only if a connection is currently active. If the special enqueueWhileDisconnected 
   * flag is specified it is possible to call the method at any time and the client will take care of sending
   * the message as soon as a connection is available, otherwise, if the current status is "DISCONNECTED*", 
   * the message will be abandoned and the [ClientMessageListener.onAbort] event will be fired. <BR>
   * Note that, in any case, as soon as the status switches again to "DISCONNECTED*", any message still pending 
   * is aborted, including messages that were queued with the enqueueWhileDisconnected flag set to true. <BR>
   * Also note that forwarding of the message to the server is made in a separate thread, hence, if a message 
   * is sent while the connection is active, it could be aborted because of a subsequent disconnection. 
   * In the same way a message sent while the connection is not active might be sent because of a subsequent
   * connection.
   * 
   * - [message] a text message, whose interpretation is entirely demanded to the Metadata Adapter
   * associated to the current connection.
   * - [sequence] an alphanumeric identifier, used to identify a subset of messages to be managed in sequence; 
   * underscore characters are also allowed. If the "UNORDERED_MESSAGES" identifier is supplied, the message will 
   * be processed in the special way described above. The parameter is optional; if set to null, "UNORDERED_MESSAGES" 
   * is used as the sequence name. 
   * - [delayTimeout] a timeout, expressed in milliseconds. If higher than the Server configured timeout
   * on missing messages, the latter will be used instead. <BR> 
   * The parameter is optional; if a negative value is supplied, the Server configured timeout on missing
   * messages will be applied. <BR>
   * This timeout is ignored for the special "UNORDERED_MESSAGES" sequence, although a server-side timeout
   * on missing messages still applies.
   * - [listener] an object suitable for receiving notifications about the processing outcome. The parameter is 
   * optional; if not supplied, no notification will be available.
   * - [enqueueWhileDisconnected] if this flag is set to true, and the client is in a disconnected status when
   * the provided message is handled, then the message is not aborted right away but is queued waiting for a new
   * session. Note that the message can still be aborted later when a new session is established.
   */
  Future<void> sendMessage(String message, [String? sequence, int? delayTimeout, ClientMessageListener? listener, bool? enqueueWhileDisconnected]) async {
    var arguments = <String, dynamic>{
      'message': message,
      'sequence': sequence,
      'delayTimeout': delayTimeout,
      'enqueueWhileDisconnected': enqueueWhileDisconnected
    };
    return await NativeBridge.instance.client_sendMessage(_id, listener, arguments);
  }

  /**
   * Adds a listener that will receive events from the LightstreamerClient instance.
   *  
   * The same listener can be added to several different LightstreamerClient instances.
   *
   * **Lifecycle** A listener can be added at any time. A call to add a listener already 
   * present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the 
   * ClientListener interface.
   * 
   * - See [removeListener]
   */
  void addListener(ClientListener listener) {
    if (!_listeners.contains(listener)) {
      _listeners.add(listener);
      scheduleMicrotask(() {
        listener.onListenStart();
      });
    }
  }

  /**
   * Removes a listener from the LightstreamerClient instance so that it will not receive events anymore.
   * 
   * **Lifecycle** a listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(ClientListener listener) {
    var found = _listeners.remove(listener);
    if (found) {
      scheduleMicrotask(() {
        listener.onListenEnd();
      });
    }
  }

  /**
   * Returns a list containing the [ClientListener] instances that were added to this client.
   *
   * **Returns** a list containing the listeners that were added to this client. 
   * - See [addListener]
   */
  List<ClientListener> getListeners() {
    return _listeners.toList();
  }

  /**
   * Operation method that registers the MPN device on the server's MPN Module.
   * 
   * By registering an MPN device, the client enables MPN functionalities such as [subscribe].
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An [MpnDevice] can be registered at any time. The registration will be notified through a [MpnDeviceListener.onRegistered] event.
   * Note that forwarding of the registration to the server is made in a separate thread.
   * 
   * - [device] An [MpnDevice] instance, carrying all the information about the MPN device.
   * 
   * **Throws** IllegalArgumentException if the specified device is null.
   * 
   * - See [subscribe]
   */
  Future<void> registerForMpn(MpnDevice device) async {
    var arguments = <String, dynamic>{
      'mpnDevId': device._id
    };
    return await NativeBridge.instance.client_registerForMpn(_id, device._id, device, arguments);
  }

  /**
   * Operation method that subscribes an MpnSubscription on server's MPN Module.
   * 
   * This operation adds the [MpnSubscription] to the list of "active" subscriptions. MPN subscriptions are activated on the server as soon as possible
   * (i.e. as soon as there is a session available and subsequently as soon as the MPN device registration succeeds). Differently than real-time subscriptions,
   * MPN subscriptions are persisted on the server's MPN Module database and survive the session they were created on.<BR>
   * If the <code>coalescing</code> flag is <i>set</i>, the activation of two MPN subscriptions with the same Adapter Set, Data Adapter, Group, Schema and trigger expression will be
   * considered the same MPN subscription. Activating two such subscriptions will result in the second activation modifying the first MpnSubscription (that
   * could have been issued within a previous session). If the <code>coalescing</code> flag is <i>not set</i>, two activations are always considered different MPN subscriptions,
   * whatever the Adapter Set, Data Adapter, Group, Schema and trigger expression are set.<BR>
   * The rationale behind the <code>coalescing</code> flag is to allow simple apps to always activate their MPN subscriptions when the app starts, without worrying if
   * the same subscriptions have been activated before or not. In fact, since MPN subscriptions are persistent, if they are activated every time the app starts and
   * the <code>coalescing</code> flag is not set, every activation is a <i>new</i> MPN subscription, leading to multiple push notifications for the same event.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An MpnSubscription can be given to the LightstreamerClient once an MpnDevice registration has been requested. The MpnSubscription
   * immediately enters the "active" state.<BR>
   * Once "active", an MpnSubscription instance cannot be provided again to an LightstreamerClient unless it is first removed from the "active" state through
   * a call to [unsubscribe].<BR>
   * Note that forwarding of the subscription to the server is made in a separate thread.<BR>
   * A successful subscription to the server will be notified through an [MpnSubscriptionListener.onSubscription] event.
   * 
   * - [sub] An MpnSubscription object, carrying all the information to route real-time data via push notifications.
   * - [coalescing] A flag that specifies if the MPN subscription must coalesce with any pre-existing MPN subscription with the same Adapter Set, Data Adapter,
   * Group, Schema and trigger expression.
   * 
   * **Throws** IllegalStateException if the given MPN subscription does not contain a field list/field schema.
   * 
   * **Throws** IllegalStateException if the given MPN subscription does not contain a item list/item group.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * **Throws** IllegalStateException if the given MPN subscription is already active.
   * 
   * - See [unsubscribe]
   * - See [unsubscribeMpnSubscriptions]
   */
  Future<void> subscribeMpn(MpnSubscription sub, bool coalescing) async {
    var arguments = <String, dynamic>{
      'subscription': sub._toMap(),
      'coalescing': coalescing
    };
    await NativeBridge.instance.client_subscribeMpn(_id, sub._id, sub, arguments);
    // NB _remoteActive is set after the remote call to ensure that, when the call returns,
    // the remote image of the local subscription has been created
    sub._remoteActive = true;
    //
    cleanResources(); // no need to await here
  }

  /**
   * Operation method that unsubscribes an MpnSubscription from the server's MPN Module.
   * 
   * This operation removes the MpnSubscription from the list of "active" subscriptions.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An MpnSubscription can be unsubscribed from at any time. Once done the MpnSubscription immediately exits the "active" state.<BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread.<BR>
   * The unsubscription will be notified through an [MpnSubscriptionListener.onUnsubscription] event.
   * 
   * - [sub] An "active" MpnSubscription object.
   * 
   * **Throws** IllegalStateException if the given MPN subscription is not active.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [subscribe]
   * - See [unsubscribeMpnSubscriptions]
   */
  Future<void> unsubscribeMpn(MpnSubscription sub) async {
    var arguments = <String, dynamic>{
      'mpnSubId': sub._id
    };
    return await NativeBridge.instance.client_unsubscribeMpn(_id, sub._id, arguments);
  }

  /**
   * Operation method that unsubscribes all the MPN subscriptions with a specified status from the server's MPN Module.
   * 
   * By specifying a status filter it is possible to unsubscribe multiple MPN subscriptions at once. E.g. by passing <code>TRIGGERED</code> it is possible
   * to unsubscribe all triggered MPN subscriptions. This operation removes the involved MPN subscriptions from the list of "active" subscriptions.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** Multiple unsubscription can be requested at any time. Once done the involved MPN subscriptions immediately exit the "active" state.<BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread.<BR>
   * The unsubscription will be notified through an [MpnSubscriptionListener.onUnsubscription] event to all involved MPN subscriptions.
   * 
   * - [filter] A status name to be used to select the MPN subscriptions to unsubscribe. If null all existing MPN subscriptions
   * are unsubscribed. Possible filter values are:<ul>
   * <li><code>ALL</code> or null</li>
   * <li><code>TRIGGERED</code></li>
   * <li><code>SUBSCRIBED</code></li>
   * </ul>
   * 
   * **Throws** IllegalArgumentException if the given filter is not valid.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [subscribe]
   * - See [unsubscribe]
   */
  Future<void> unsubscribeMpnSubscriptions([ String? filter ]) async {
    var arguments = <String, dynamic>{
      'filter': filter
    };
    return await _invokeMethod('unsubscribeMpnSubscriptions', arguments);
  }

  /**
   * Inquiry method that returns a collection of the existing MPN subscription with a specified status.
   * 
   * Can return both objects created by the user, via [MpnSubscription] constructors, and objects created by the client, to represent pre-existing MPN subscriptions.<BR>
   * Note that objects in the collection may be substituted at any time with equivalent ones: do not rely on pointer matching, instead rely on the
   * [MpnSubscription.getSubscriptionId] value to verify the equivalence of two MpnSubscription objects. Substitutions may happen
   * when an MPN subscription is modified, or when it is coalesced with a pre-existing subscription.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** The collection is available once an MpnDevice registration has been requested, but reflects the actual server's collection only
   * after an [MpnDeviceListener.onSubscriptionsUpdated] event has been notified.
   * 
   * - [filter] An MPN subscription status name to be used to select the MPN subscriptions to return. If null all existing MPN subscriptions
   * are returned. Possible filter values are:<ul>
   * <li><code>ALL</code> or null</li>
   * <li><code>TRIGGERED</code></li>
   * <li><code>SUBSCRIBED</code></li>
   * </ul>
   * 
   * **Returns** the collection of [MpnSubscription] with the specified status.
   * 
   * **Throws** IllegalArgumentException if the given filter is not valid.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [findMpnSubscription]
   */
  Future<List<MpnSubscription>> getMpnSubscriptions([ String? filter ]) async {
    var arguments = <String, dynamic>{
      'filter': filter
    };
    return await NativeBridge.instance.client_getMpnSubscriptions(_id, arguments);
  }

  /**
   * Inquiry method that returns the MpnSubscription with the specified subscription ID, or null if not found.
   * 
   * The object returned by this method can be an object created by the user, via MpnSubscription constructors, or an object created by the client,
   * to represent pre-existing MPN subscriptions.<BR>
   * Note that objects returned by this method may be substitutued at any time with equivalent ones: do not rely on pointer matching, instead rely on the
   * [MpnSubscription.getSubscriptionId] value to verify the equivalence of two MpnSubscription objects. Substitutions may happen
   * when an MPN subscription is modified, or when it is coalesced with a pre-existing subscription.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * - [subscriptionId] The subscription ID to search for.
   * 
   * **Returns** the MpnSubscription with the specified ID, or null if not found.
   * 
   * **Throws** IllegalArgumentException if the given subscription ID is null.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [getMpnSubscriptions]
   */
  Future<MpnSubscription?> findMpnSubscription(String subscriptionId) async {
    var arguments = <String, dynamic>{
      'subscriptionId': subscriptionId
    };
    return await NativeBridge.instance.client_findMpnSubscription(_id, arguments);
  }

  Future<T> _invokeMethod<T>(String method, [ Map<String, dynamic>? arguments ]) async {
    arguments = arguments ?? {};
    arguments["id"] = _id;
    return await NativeBridge.instance.invokeMethod('LightstreamerClient.$method', arguments);
  }
}

/**
 * Used by LightstreamerClient to provide a basic connection properties data object.
 *
 * Data object that contains the configuration settings needed
 * to connect to a Lightstreamer Server. <BR>
 * An instance of this class is attached to every [LightstreamerClient]
 * as [LightstreamerClient.connectionDetails]<BR>
 * 
 * - See LightstreamerClient
 */
class ConnectionDetails {
  final String _id;
  String? _adapterSet;
  String? _serverAddress;
  String? _user;
  String? _password;
  // read-only properties
  String? _serverInstanceAddress;
	String? _serverSocketName;
  String? _clientIp;
	String? _sessionId;

  Map<String, dynamic> _toMap() {
    return {
      "adapterSet": _adapterSet,
      "serverAddress": _serverAddress,
      "user": _user,
      "password": _password
    };
  }

  ConnectionDetails._(String clientId) : _id = clientId;

  /**
   * Inquiry method that gets the name of the Adapter Set (which defines the Metadata Adapter and one or several 
   * Data Adapters) mounted on Lightstreamer Server that supply all the items used in this application.
   * 
   * **Returns** the adapterSet the name of the Adapter Set; returns null if no name has been configured, that 
   * means that the "DEFAULT" Adapter Set is used.
   * 
   * - See [setAdapterSet]
   */
  String? getAdapterSet() {
    return _adapterSet;
  }

  /**
   * Setter method that sets the name of the Adapter Set mounted on Lightstreamer Server to be used to handle 
   * all requests in the session.
   * 
   * An Adapter Set defines the Metadata Adapter and one or several Data Adapters. It is configured on the 
   * server side through an "adapters.xml" file; the name is configured through the "id" attribute in 
   * the &lt;adapters_conf&gt; element.
   * 
   * **Default** The default Adapter Set, configured as "DEFAULT" on the Server.
   * 
   * **Lifecycle** The Adapter Set name should be set on the [LightstreamerClient.connectionDetails] object 
   * before calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: 
   * the supplied value will be used for the next time a new session is requested to the server. <BR>
   * This setting can also be specified in the [LightstreamerClient] constructor.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "adapterSet" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The name of the Adapter Set to be used. A null value is equivalent to the "DEFAULT" name.
   */
  void setAdapterSet(String? newVal) {
    _adapterSet = newVal;
  }

  /**
   * Inquiry method that gets the configured address of Lightstreamer Server.
   *
   * **Returns** the serverAddress the configured address of Lightstreamer Server.
   */
  String? getServerAddress() {
    return _serverAddress;
  }

  /**
   * Setter method that sets the address of Lightstreamer Server.
   * 
   * Note that the addresses specified must always have the http: or https: scheme. In case WebSockets are used, 
   * the specified scheme is internally converted to match the related WebSocket protocol (i.e. http becomes ws 
   * while https becomes wss).
   *
   * **General Edition Note** WSS/HTTPS is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** if no server address is supplied the client will be unable to connect.
   * 
   * **Lifecycle** This method can be called at any time. If called while connected, it will be applied when the next 
   * session creation request is issued. This setting can also be specified in the [LightstreamerClient]
   * constructor.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverAddress" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The full address of Lightstreamer Server. A null value can also be used, to restore the default value. 
   * An IPv4 or IPv6 can also be used in place of a hostname. Some examples of valid values include:
   * 
   * - `http://push.mycompany.com`
   * - `http://push.mycompany.com:8080`
   * - `http://79.125.7.252`
   * - `http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]`
   * - `http://[2001:0db8:85a3::8a2e:0370:7334]:8080`
   * 
   * **Throws** IllegalArgumentException if the given address is not valid.
   */
  Future<void> setServerAddress(String? newVal) async {
    _serverAddress = newVal;
     var arguments = <String, dynamic> {
      'newVal': newVal
    };
    return await _invokeMethod('setServerAddress', arguments);
  }

  /**
   * Inquiry method that gets the username to be used for the authentication on Lightstreamer Server when initiating the session.
   * 
   * **Returns** the username to be used for the authentication on Lightstreamer Server; returns null if no 
   * user name has been configured.
   */
  String? getUser() {
    return _user;
  }

  /**
   * Setter method that sets the username to be used for the authentication on Lightstreamer Server when initiating the session. 
   * 
   * The Metadata Adapter is responsible for checking the credentials (username and password).
   * 
   * **Default** If no username is supplied, no user information will be sent at session initiation. 
   * The Metadata Adapter, however, may still allow the session.
   * 
   * **Lifecycle** The username should be set on the [LightstreamerClient.connectionDetails] object before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the 
   * supplied value will be used for the next time a new session is requested to the server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "user" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The username to be used for the authentication on Lightstreamer Server. The username can be null.
   * 
   * - See [setPassword]
   */
  void setUser(String? newVal) {
    _user = newVal;
  }

  /**
   * Inquiry method that gets the server address to be used to issue all requests related to the current session. 
   * 
   * In fact, when a Server cluster is in place, the Server address specified through [setServerAddress] can 
   * identify various Server instances; in order to ensure that all requests related to a session are issued to 
   * the same Server instance, the Server can answer to the session opening request by providing an address which 
   * uniquely identifies its own instance. When this is the case, this address is returned by the method; otherwise,
   * null is returned. <BR> 
   * Note that the addresses will always have the http: or https: scheme. In case WebSockets are used, the specified 
   * scheme is internally converted to match the related WebSocket protocol (i.e. http becomes ws while 
   * https becomes wss).
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value may become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverInstanceAddress" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** address used to issue all requests related to the current session, or null.
   */
  String? getServerInstanceAddress() {
    return _serverInstanceAddress;
  }

  /**
   * Inquiry method that gets the instance name of the Server which is serving the current session. 
   * 
   * To be more precise, 
   * each answering port configured on a Server instance (through a &lt;http_server&gt; or &lt;https_server&gt; element in the 
   * Server configuration file) can be given a different name; the name related to the port to which the session 
   * opening request has been issued is returned. <BR> 
   * Note that each rebind to the same session can, potentially, reach the Server on a port different than the one
   * used for the previous request, depending on the behavior of intermediate nodes. However, the only meaningful case
   * is when a Server cluster is in place and it is configured in such a way that the port used for all bind_session requests
   * differs from the port used for the initial create_session request.
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default, available at /dashboard).
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverSocketName" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** name configured for the Server instance which is managing the current session, or null.
   */
  String? getServerSocketName() {
    return _serverSocketName;
  }

  /**
   * Inquiry method that gets the IP address of this client as seen by the Server which is serving the current session as the client remote address.
   * 
   * Note that it may not correspond to the client host.For instance, it may refer to an intermediate proxy. 
   * 
   * If, upon a new session, this address changes,
   * it may be a hint that the intermediary network nodes handling the connection have changed, hence the network
   * capabilities may be different. The library uses this information to optimize the connection. <BR>  
   * Note that in case of polling or in case rebind requests are needed, subsequent requests related to the same 
   * session may, in principle, expose a different IP address to the Server; these changes would not be reported.
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value may become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "clientIp" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns**  A canonical representation of an IP address (it can be either IPv4 or IPv6), or null.
   */
  String? getClientIp() {
    return _clientIp;
  }

  /**
   * Inquiry method that gets the ID associated by the server to this client session.
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "sessionId" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** ID assigned by the Server to this client session, or null.
   */
  String? getSessionId() {
    return _sessionId;
  }

  /**
   * Setter method that sets the password to be used for the authentication on Lightstreamer Server when initiating the session. 
   * 
   * The Metadata Adapter is responsible for checking the credentials (username and password).
   * 
   * **Default**  If no password is supplied, no password information will be sent at session initiation. 
   * The Metadata Adapter, however, may still allow the session.
   * 
   * **Lifecycle** The username should be set on the [LightstreamerClient.connectionDetails] object before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied 
   * value will be used for the next time a new session is requested to the server. <BR>
   * NOTE: The password string will be stored in the current instance. That is necessary in order to allow 
   * automatic reconnection/reauthentication for fail-over. For maximum security, avoid using an actual private 
   * password to authenticate on Lightstreamer Server; rather use a session-id originated by your web/application 
   * server, that can be checked by your Metadata Adapter.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "password" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The password to be used for the authentication on Lightstreamer Server. 
   *        The password can be null.
   *        
   * - See [setUser]
   */
  void setPassword(String? newVal) {
    _password = newVal;
  }

  Future<T> _invokeMethod<T>(String method, [ Map<String, dynamic>? arguments ]) async {
    arguments = arguments ?? {};
    arguments["id"] = _id;
    return await NativeBridge.instance.invokeMethod('ConnectionDetails.$method', arguments);
  }
}

/**
 * Used by LightstreamerClient to provide an extra connection properties data object.
 *
 * Data object that contains the policy settings used to connect to a 
 * Lightstreamer Server. <BR>
 * An instance of this class is attached to every [LightstreamerClient]
 * as [LightstreamerClient.connectionOptions]<BR>
 * 
 * - See LightstreamerClient
 */
class ConnectionOptions {
  // WARNING: The field default values must be kept in sync with the defaults of the other Lightstreamer Client SDKs
  final String _id;
  int _contentLength = 50000000;
  int _firstRetryMaxDelay = 100;
  String? _forcedTransport;
  Map<String, String>? _httpExtraHeaders;
  int _idleTimeout = 19000;
  int _keepaliveInterval = 0;
  int _pollingInterval = 0;
  int _reconnectTimeout = 3000;
  String _requestedMaxBandwidth = "unlimited";
  int _retryDelay = 4000;
  int _reverseHeartbeatInterval = 0;
  int _sessionRecoveryTimeout = 15000;
  int _stalledTimeout = 2000;
  bool _httpExtraHeadersOnSessionCreationOnly = false;
  bool _serverInstanceAddressIgnored = false;
  bool _slowingEnabled = false;
  // read-only properties
  String? _realMaxBandwidth;

  Map<String, dynamic> _toMap() {
    return {
      "contentLength": _contentLength,
      "firstRetryMaxDelay": _firstRetryMaxDelay,
      "forcedTransport": _forcedTransport,
      "httpExtraHeaders": _httpExtraHeaders,
      "idleTimeout": _idleTimeout,
      "keepaliveInterval": _keepaliveInterval,
      "pollingInterval": _pollingInterval,
      "reconnectTimeout": _reconnectTimeout,
      "requestedMaxBandwidth": _requestedMaxBandwidth,
      "retryDelay": _retryDelay,
      "reverseHeartbeatInterval": _reverseHeartbeatInterval,
      "sessionRecoveryTimeout": _sessionRecoveryTimeout,
      "stalledTimeout": _stalledTimeout,
      "httpExtraHeadersOnSessionCreationOnly": _httpExtraHeadersOnSessionCreationOnly,
      "serverInstanceAddressIgnored": _serverInstanceAddressIgnored,
      "slowingEnabled": _slowingEnabled
    };
  }

  ConnectionOptions._(String clientId) : _id = clientId;

  /**
   * Inquiry method that gets the length expressed in bytes to be used by the Server for the response body on a HTTP stream connection.
   *
   * **Returns** The length to be used by the Server for the response body on a HTTP stream connection
   * - See [setContentLength]
   */
  int getContentLength() {
    return _contentLength;
  }

  /**
   * Setter method that sets the length in bytes to be used by the Server for the response body on a stream connection (a minimum length, however, is ensured by the server). 
   * 
   * After the content length exhaustion, the connection will
   * be closed and a new bind connection will be automatically reopened.<BR>
   * NOTE that this setting only applies to the "HTTP-STREAMING" case (i.e. not to WebSockets).
   * 
   * **Default** A length decided by the library, to ensure the best performance.
   * It can be of a few MB or much higher, depending on the environment.
   * 
   * **Lifecycle** The content length should be set before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will 
   * be used for the next streaming connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "contentLength" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The length to be used by the Server for the response body on a HTTP stream connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   */
  void setContentLength(int newVal) {
    _contentLength = newVal;
  }

  /**
   * Inquiry method that gets the maximum time to wait before trying a new connection to the Server in case the previous one is unexpectedly closed while correctly working.
   *
   * **Returns** The max time (in milliseconds) to wait before trying a new connection.
   * - See [setFirstRetryMaxDelay]
   */
  int getFirstRetryMaxDelay() {
    return _firstRetryMaxDelay;
  }

  /**
   * Setter method that sets the maximum time to wait before trying a new connection to the Server in case the previous one is unexpectedly closed while correctly working.
   * 
   * The new connection may be either the opening of a new session or an attempt to recovery
   * the current session, depending on the kind of interruption. <BR>
   * The actual delay is a randomized value between 0 and this value. 
   * This randomization might help avoid a load spike on the cluster due to simultaneous reconnections, should one of 
   * the active servers be stopped. Note that this delay is only applied before the first reconnection: should such 
   * reconnection fail, only the setting of [setRetryDelay] will be applied.
   * 
   * **Default** 100 (0.1 seconds)
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "firstRetryMaxDelay" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The max time (in milliseconds) to wait before trying a new connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   */
  void setFirstRetryMaxDelay(int newVal) {
    _firstRetryMaxDelay = newVal;
  }

  /**
   * Inquiry method that gets the value of the forced transport (if any).
   *
   * **Returns** The forced transport or null
   * - See [setForcedTransport]
   */
  String? getForcedTransport() {
    return _forcedTransport;
  }

  /**
   * Setter method that can be used to disable/enable the Stream-Sense algorithm and to force the client to use a fixed transport or a fixed combination of a transport and a connection type. 
   * 
   * When a combination is specified the 
   * Stream-Sense algorithm is completely disabled. <BR>
   * The method can be used to switch between streaming and polling connection types and between 
   * HTTP and WebSocket transports. <BR>
   * In some cases, the requested status may not be reached, because of connection or environment problems. In that case 
   * the client will continuously attempt to reach the configured status. <BR>
   * Note that if the Stream-Sense algorithm is disabled, the client may still enter the "CONNECTED:STREAM-SENSING" status; 
   * however, in that case, if it eventually finds out that streaming is not possible, no recovery will be tried.
   * 
   * **Default** null (full Stream-Sense enabled).
   * 
   * **Lifecycle** This method can be called at any time. If called while the client is connecting or connected it will instruct 
   * to switch connection type to match the given configuration.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "forcedTransport" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] can be one of the following: 
   * <ul>
   *  <li>null: the Stream-Sense algorithm is enabled and the client will automatically connect using the most 
   *  appropriate transport and connection type among those made possible by the environment.</li>
   *  <li>"WS": the Stream-Sense algorithm is enabled as in the null case but the client will only use WebSocket 
   *  based connections. If a connection over WebSocket is not possible because of the environment the client 
   *  will not connect at all.</li>
   *  <li>"HTTP": the Stream-Sense algorithm is enabled as in the null case but the client will only use HTTP based 
   *  connections. If a connection over HTTP is not possible because of the environment the client will not 
   *  connect at all.</li>
   *  <li>"WS-STREAMING": the Stream-Sense algorithm is disabled and the client will only connect on Streaming over 
   *  WebSocket. If Streaming over WebSocket is not possible because of the environment the client will not 
   *  connect at all.</li>
   *  <li>"HTTP-STREAMING": the Stream-Sense algorithm is disabled and the client will only connect on Streaming over HTTP. 
   *  If Streaming over HTTP is not possible because of the browser/environment the client will not connect at all.</li>
   *  <li>"WS-POLLING": the Stream-Sense algorithm is disabled and the client will only connect on Polling over WebSocket. 
   *  If Polling over WebSocket is not possible because of the environment the client will not connect at all.</li>
   *  <li>"HTTP-POLLING": the Stream-Sense algorithm is disabled and the client will only connect on Polling over HTTP.
   *  If Polling over HTTP is not possible because of the environment the client will not connect at all.</li>
   * </ul>
   * 
   * **Throws** IllegalArgumentException if the given value is not in the list of the admitted ones.
   */
  Future<void> setForcedTransport(String? newVal) async {
    _forcedTransport = newVal;
    var arguments = <String, dynamic> {
      'newVal': newVal
    };
    return await _invokeMethod('setForcedTransport', arguments);
  }

  /**
   * Inquiry method that gets the Map object containing the extra headers to be sent to the server.
   *
   * **Returns** The Map object containing the extra headers to be sent
   * - See [setHttpExtraHeaders]
   * - See [setHttpExtraHeadersOnSessionCreationOnly]
   */
  Map<String, String>? getHttpExtraHeaders() {
    return _httpExtraHeaders;
  }

  /**
   * Setter method that enables/disables the setting of extra HTTP headers to all the request performed to the Lightstreamer server by the client.
   * 
   * Note that the Content-Type header is reserved by the client library itself, while other headers might be refused by the 
   * environment and others might cause the connection to the server to fail.
   * <BR> For instance, you cannot use this method to specify custom cookies to be sent to
   * Lightstreamer Server; leverage [LightstreamerClient.addCookies] instead.
   * The use of custom headers might also cause the
   * client to send an OPTIONS request to the server before opening the actual connection. 
   * 
   * **Default** null (meaning no extra headers are sent).
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the supplied value will be used for the next HTTP request or WebSocket establishment.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "httpExtraHeaders" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] a Map object containing header-name header-value pairs. Null can be specified to avoid extra 
   * headers to be sent.
   */
  void setHttpExtraHeaders(Map<String, String>? newVal) {
    _httpExtraHeaders = newVal;
  }

  /**
   * Inquiry method that gets the maximum time the Server is allowed to wait for any data to be sent in response to a polling request, if none has accumulated at request time. 
   * 
   * The wait time used by the Server, however, may be different, because of server side restrictions.
   *
   * **Returns** The time (in milliseconds) the Server is allowed to wait for data to send upon 
   * polling requests.
   * - See [setIdleTimeout]
   */
  int getIdleTimeout() {
    return _idleTimeout;
  }

  /**
   * Setter method that sets the maximum time the Server is allowed to wait for any data to be sent in response to a polling request, if none has accumulated at request time. 
   * 
   * Setting this time to a nonzero value and the polling interval 
   * to zero leads to an "asynchronous polling" behavior, which, on low data rates, is very similar to the streaming case.
   * Setting this time to zero and the polling interval to a nonzero value, on the other hand, leads to a classical 
   * "synchronous polling". <BR>
   * Note that the Server may, in some cases, delay the answer for more than the supplied time, to protect itself against
   * a high polling rate or because of bandwidth restrictions. Also, the Server may impose an upper limit on the wait time, 
   * in order to be able to check for client-side connection drops.
   * 
   * **Default**  19000 (19 seconds).
   * 
   * **Lifecycle** The idle timeout should be set before calling the 
   * [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value 
   * will be used for the next polling request.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "idleTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) the Server is allowed to wait for data to send upon polling requests.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   */
  void setIdleTimeout(int newVal) {
    _idleTimeout = newVal;
  }

  /**
   * Inquiry method that gets the interval between two keepalive packets sent by Lightstreamer Server on a stream connection when no actual data is being transmitted. 
   * 
   * If the returned value is 0, it means that the interval is to be decided by the Server upon the next connection.
   * 
   * **Lifecycle** If the value has just been set and a connection to Lightstreamer Server has not been
   * established yet, the returned value is the time that is being requested to the Server.
   * Afterwards, the returned value is the time used by the Server, that may be different, because
   * of Server side constraints.
   * 
   * **Returns** The time, expressed in milliseconds, between two keepalive packets sent by the Server, or 0.
   * 
   * - See [setKeepaliveInterval]
   */
  int getKeepaliveInterval() {
    return _keepaliveInterval;
  }

  /**
   * Setter method that sets the interval between two keepalive packets to be sent by Lightstreamer Server on a stream connection when no actual data is being transmitted. 
   * 
   * The Server may, however, impose a lower limit on the keepalive 
   * interval, in order to protect itself. Also, the Server may impose an upper limit on the keepalive interval, in 
   * order to be able to check for client-side connection drops.
   * If 0 is specified, the interval will be decided by the Server.
   * 
   * **Default** 0 (meaning that the Server will send keepalive packets based on its own configuration).
   * 
   * **Lifecycle** The keepalive interval should be set before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied 
   * value will be used for the next streaming connection (either a bind or a brand new session). <BR>
   * Note that, after a connection, the value may be changed to the one imposed by the Server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "keepaliveInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   *
   * - [newVal] the keepalive interval time (in milliseconds) to set, or 0.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   * 
   * - See [setStalledTimeout]
   * - See [setReconnectTimeout]
   */
  void setKeepaliveInterval(int newVal) {
    _keepaliveInterval = newVal;
  }

  /**
   * Inquiry method that gets the polling interval used for polling connections.
   * 
   * If the value has just been set and a polling request to Lightstreamer Server has not been performed 
   * yet, the returned value is the polling interval that is being requested to the Server. Afterwards, 
   * the returned value is the the time between subsequent polling requests that is really allowed by the 
   * Server, that may be different, because of Server side constraints.
   *
   * **Returns** The time (in milliseconds) between subsequent polling requests.
   * - See [setPollingInterval]
   */
  int getPollingInterval() {
    return _pollingInterval;
  }

  /**
   * Setter method that sets the polling interval used for polling connections. 
   * 
   * The client switches from the default streaming mode to polling mode when the client network infrastructure does not allow streaming. Also, 
   * polling mode can be forced by calling [setForcedTransport] with "WS-POLLING" or "HTTP-POLLING" 
   * as parameter. <BR>
   * The polling interval affects the rate at which polling requests are issued. It is the time between the start of a 
   * polling request and the start of the next request. However, if the polling interval expires before the first polling 
   * request has returned, then the second polling request is delayed. This may happen, for instance, when the Server delays 
   * the answer because of the idle timeout setting. In any case, the polling interval allows for setting an upper limit on 
   * the polling frequency. <BR> 
   * The Server does not impose a lower limit on the client polling interval. However, in some cases, it may protect itself
   * against a high polling rate by delaying its answer. Network limitations and configured bandwidth limits may also lower 
   * the polling rate, despite of the client polling interval. <BR>
   * The Server may, however, impose an upper limit on the polling interval, in order to be able to promptly detect 
   * terminated polling request sequences and discard related session information.
   * 
   * **Default** 0 (pure "asynchronous polling" is configured).
   * 
   * **Lifecycle** The polling interval should be set before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will
   * be used for the next polling request. <BR>
   * Note that, after each polling request, the value may be changed to the one imposed by the Server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "pollingInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) between subsequent polling requests. Zero is a legal value too, 
   * meaning that the client will issue a new polling request as soon as a previous one has returned.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   */
  void setPollingInterval(int newVal) {
    _pollingInterval = newVal;
  }

  /**
   * Inquiry method that gets the maximum bandwidth that can be consumed for the data coming from Lightstreamer Server. 
   * 
   * This is the actual maximum bandwidth, in contrast with the requested
   * maximum bandwidth, returned by [getRequestedMaxBandwidth]. <BR>
   * The value may differ from the requested one because of restrictions operated on the server side,
   * or because bandwidth management is not supported (in this case it is always "unlimited"),
   * but also because of number rounding.
   * 
   * **Lifecycle** If a connection to Lightstreamer Server is not currently active, null is returned;
   * soon after the connection is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "realMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns**  A decimal number, which represents the maximum bandwidth applied by the Server for the
   * streaming or polling connection expressed in kbps (kilobits/sec), or the string "unlimited", or null.
   * - See [setRequestedMaxBandwidth]
   */
  String? getRealMaxBandwidth() {
    return _realMaxBandwidth;
  }

  /**
   * Inquiry method that gets the time the client, after entering "STALLED" status,
   * is allowed to keep waiting for a keepalive packet or any data on a stream connection,
   * before disconnecting and trying to reconnect to the Server.
   *
   * **Returns** The idle time (in milliseconds) admitted in "STALLED" status before trying to 
   * reconnect to the Server.
   * - See [setReconnectTimeout]
   */
  int getReconnectTimeout() {
    return _reconnectTimeout;
  }

  /**
   * Setter method that sets the time the client, after entering "STALLED" status,
   * is allowed to keep waiting for a keepalive packet or any data on a stream connection,
   * before disconnecting and trying to reconnect to the Server.
   * 
   * The new connection may be either the opening of a new session or an attempt to recovery
   * the current session, depending on the kind of interruption.
   * 
   * **Default** 3000 (3 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "reconnectTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The idle time (in milliseconds) allowed in "STALLED" status before trying
   * to reconnect to the Server.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setStalledTimeout]
   * - See [setKeepaliveInterval]
   */
  void setReconnectTimeout(int newVal) {
    _reconnectTimeout = newVal;
  }

  /**
   * Inquiry method that gets the maximum bandwidth that can be consumed for the data coming from Lightstreamer Server, as requested for this session.
   * 
   * The maximum bandwidth limit really applied by the Server on the session is provided by
   * [getRealMaxBandwidth]
   * 
   * **Returns**  A decimal number, which represents the maximum bandwidth requested for the streaming
   * or polling connection expressed in kbps (kilobits/sec), or the string "unlimited".
   * - See [setRequestedMaxBandwidth]
   */
  String getRequestedMaxBandwidth() {
    return _requestedMaxBandwidth;
  }

  /**
   * Setter method that sets the maximum bandwidth expressed in kilobits/s that can be consumed for the data coming from Lightstreamer Server. 
   * 
   * A limit on bandwidth may already be posed by the Metadata Adapter, but the client can 
   * further restrict this limit. The limit applies to the bytes received in each streaming or polling connection.
   * 
   * **General Edition Note** Bandwidth Control is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** "unlimited"
   * 
   * **Lifecycle** The bandwidth limit can be set and changed at any time. If a connection is currently active, the bandwidth 
   * limit for the connection is changed on the fly. Remember that the Server may apply a different limit.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "requestedMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient. <BR>
   * Moreover, upon any change or attempt to change the limit, the Server will notify the client
   * and such notification will be received through a call to 
   * [ClientListener.onPropertyChange] with argument "realMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal]  A decimal number, which represents the maximum bandwidth requested for the streaming
   * or polling connection expressed in kbps (kilobits/sec). The string "unlimited" is also allowed, to mean that
   * the maximum bandwidth can be entirely decided on the Server side (the check is case insensitive).
   * 
   * **Throws** IllegalArgumentException if a negative, zero, or a not-number value (excluding special values) is passed.
   * 
   * - See [getRealMaxBandwidth]
   */
  Future<void> setRequestedMaxBandwidth(String newVal) async {
    _requestedMaxBandwidth = newVal;
    var arguments = <String, dynamic> {
      'newVal': newVal
    };
    return await _invokeMethod('setRequestedMaxBandwidth', arguments);
  }

  /**
   * Inquiry method that gets the minimum time to wait before trying a new connection
   * to the Server in case the previous one failed for any reason, which is also the maximum time to wait for a response to a request before dropping the connection and trying with a different approach.
   * 
   * Note that the delay is calculated from the moment the effort to create a connection
   * is made, not from the moment the failure is detected or the connection timeout expires.
   *
   * **Returns** The time (in milliseconds) to wait before trying a new connection.
   * - See [setRetryDelay]
   */
  int getRetryDelay() {
    return _retryDelay;
  }

  /** 
   * Setter method that sets 
   * <ol>
   * <li>the minimum time to wait before trying a new connection
   * to the Server in case the previous one failed for any reason; and</li>
   * <li>the maximum time to wait for a response to a request 
   * before dropping the connection and trying with a different approach.</li>
   * </ol>
   * 
   * Enforcing a delay between reconnections prevents strict loops of connection attempts when these attempts
   * always fail immediately because of some persisting issue.
   * This applies both to reconnections aimed at opening a new session and to reconnections
   * aimed at attempting a recovery of the current session.<BR>
   * Note that the delay is calculated from the moment the effort to create a connection
   * is made, not from the moment the failure is detected.
   * As a consequence, when a working connection is interrupted, this timeout is usually
   * already consumed and the new attempt can be immediate (except that
   * [ConnectionOptions.setFirstRetryMaxDelay] will apply in this case).
   * As another consequence, when a connection attempt gets no answer and times out,
   * the new attempt will be immediate.<BR>
   * <BR>
   * As a timeout on unresponsive connections, it is applied in these cases:
   * <ul>
   * <li><i>Streaming</i>: Applied on any attempt to setup the streaming connection. If after the 
   * timeout no data has arrived on the stream connection, the client may automatically switch transport 
   * or may resort to a polling connection.</li>
   * <li><i>Polling and pre-flight requests</i>: Applied on every connection. If after the timeout 
   * no data has arrived on the polling connection, the entire connection process restarts from scratch.</li>
   * </ul>
   * <BR>
   * <b>This setting imposes only a minimum delay. In order to avoid network congestion, the library may use a longer delay if the issue preventing the
   * establishment of a session persists.</b>
   * 
   * **Default** 4000 (4 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "retryDelay" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) to wait before trying a new connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setFirstRetryMaxDelay]
   */
  void setRetryDelay(int newVal) {
    _retryDelay = newVal;
  }

  /**
   * Inquiry method that gets the reverse-heartbeat interval expressed in milliseconds.
   * 
   * A 0 value is possible, meaning that the mechanism is disabled.
   *
   * **Returns** The reverse-heartbeat interval, or 0.
   * - See [setReverseHeartbeatInterval]
   */
  int getReverseHeartbeatInterval() {
    return _reverseHeartbeatInterval;
  }

  /**
   * Setter method that enables/disables the reverse-heartbeat mechanism by setting the
   * heartbeat interval. 
   * 
   * If the given value (expressed in milliseconds) equals 0 then the reverse-heartbeat mechanism will be disabled; otherwise if the given value is greater than 0 the mechanism will be enabled with the specified interval.
   * 
   * When the mechanism is active, the client will ensure that there
   * is at most the specified interval between a control request and the following one,
   * by sending empty control requests (the "reverse heartbeats") if necessary.
   * <BR>This can serve various purposes:<ul>
   * <li>Preventing the communication infrastructure from closing an inactive socket
   * that is ready for reuse for more HTTP control requests, 
   * to avoid connection reestablishment overhead. However it is not guaranteed that the connection will be kept open,
   * as the underlying TCP implementation may open a new socket each time a HTTP request needs to be sent.<BR>
   * Note that this will be done only when a session is in place.</li>
   * <li>Allowing the Server to detect when a streaming connection or Websocket
   * is interrupted but not closed. In these cases, the client eventually closes
   * the connection, but the Server cannot see that (the connection remains "half-open")
   * and just keeps trying to write. This is done by notifying the timeout to the Server
   * upon each streaming request. For long polling, the [setIdleTimeout] setting
   * has a similar function.</li>
   * <li>Allowing the Server to detect cases in which the client has closed a connection
   * in HTTP streaming, but the socket is kept open by some intermediate node,
   * which keeps consuming the response.
   * This is also done by notifying the timeout to the Server upon each streaming request,
   * whereas, for long polling, the [setIdleTimeout] setting has a similar function.</li>
   * </ul>
   * 
   * **Default** 0 (meaning that the mechanism is disabled).
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the setting will be obeyed immediately, unless a higher heartbeat
   * frequency was notified to the Server for the current connection. The setting
   * will always be obeyed upon the next connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "reverseHeartbeatInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] the interval, expressed in milliseconds, between subsequent reverse-heartbeats, or 0.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured
   */
  Future<void> setReverseHeartbeatInterval(int newVal) async {
    _reverseHeartbeatInterval = newVal;
    var arguments = <String, dynamic> {
      'newVal': newVal
    };
    return await _invokeMethod('setReverseHeartbeatInterval', arguments);
  }

  /**
   * Inquiry method that gets the maximum time allowed for attempts to recover
   * the current session upon an interruption, after which a new session will be created.
   * 
   * A 0 value also means that any attempt to recover the current session is prevented
   * in the first place.
   * 
   * **Returns** The maximum time allowed for recovery attempts, possibly 0.
   * - See [setSessionRecoveryTimeout]
   */
  int getSessionRecoveryTimeout() {
    return _sessionRecoveryTimeout;
  }

  /**
   * Setter method that sets the maximum time allowed for attempts to recover
   * the current session upon an interruption, after which a new session will be created.
   * 
   * If the given value (expressed in milliseconds) equals 0, then any attempt
   * to recover the current session will be prevented in the first place.
   * <BR>In fact, in an attempt to recover the current session, the client will
   * periodically try to access the Server at the address related with the current
   * session. In some cases, this timeout, by enforcing a fresh connection attempt,
   * may prevent an infinite sequence of unsuccessful attempts to access the Server.
   * <BR>Note that, when the Server is reached, the recovery may fail due to a
   * Server side timeout on the retention of the session and the updates sent.
   * In that case, a new session will be created anyway.
   * A setting smaller than the Server timeouts may prevent such useless failures,
   * but, if too small, it may also prevent successful recovery in some cases.
   * 
   * **Default** 15000 (15 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a
   * call to [ClientListener.onPropertyChange] with argument "sessionRecoveryTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The maximum time allowed
   * for recovery attempts, expressed in milliseconds, including 0.
   *
   * **Throws** IllegalArgumentException if a negative value is passed.
   */
  void setSessionRecoveryTimeout(int newVal) {
    _sessionRecoveryTimeout = newVal;
  }

  /**
   * Inquiry method that gets the extra time the client can wait when an expected keepalive packet has not been received on a stream connection (and no actual data has arrived), before entering the "STALLED" status.
   *
   * **Returns** The idle time (in milliseconds) admitted before entering the "STALLED" status.
   * - See [setStalledTimeout]
   */
  int getStalledTimeout() {
    return _stalledTimeout;
  }

  /**
   * Setter method that sets the extra time the client is allowed to wait when an expected keepalive packet has not been received on a stream connection (and no actual data has arrived), before entering the "STALLED" status.
   * 
   * **Default** 2000 (2 seconds).
   * 
   * **Lifecycle**  This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "stalledTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The idle time (in milliseconds) allowed before entering the "STALLED" status.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setReconnectTimeout]
   * - See [setKeepaliveInterval]
   */
  void setStalledTimeout(int newVal) {
    _stalledTimeout = newVal;
  }

  /**
   * Inquiry method that checks if the restriction on the forwarding of the configured extra http headers applies or not. 
   *
   * **Returns** the httpExtraHeadersOnSessionCreationOnly
   * - See [setHttpExtraHeadersOnSessionCreationOnly]
   * - See [setHttpExtraHeaders]
   */
  bool isHttpExtraHeadersOnSessionCreationOnly() {
    return _httpExtraHeadersOnSessionCreationOnly;
  }

  /**
   * Setter method that enables/disables a restriction on the forwarding of the extra http headers specified through [setHttpExtraHeaders]. 
   * 
   * If true, said headers will only be sent during the session creation 
   * process (and thus will still be available to the metadata adapter notifyUser method) but will not be sent on following 
   * requests. On the contrary, when set to true, the specified extra headers will be sent to the server on every request.
   * 
   * **Default** false
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the supplied value will be used for the next HTTP request or WebSocket establishment.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "httpExtraHeadersOnSessionCreationOnly" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true/false to enable/disable the restriction on extra headers forwarding.
   */
  void setHttpExtraHeadersOnSessionCreationOnly(bool newVal) {
    _httpExtraHeadersOnSessionCreationOnly = newVal;
  }

  /**
   * Inquiry method that checks if the client is going to ignore the server instance address that will possibly be sent by the server.
   *
   * **Returns** Whether or not to ignore the server instance address sent by the server.
   * - See [setServerInstanceAddressIgnored]
   */
  bool isServerInstanceAddressIgnored() {
    return _serverInstanceAddressIgnored;
  }

  /**
   * Setter method that can be used to disable/enable the automatic handling of server instance address that may be returned by the Lightstreamer server during session creation.
   * 
   * In fact, when a Server cluster is in place, the Server address specified through 
   * [ConnectionDetails.setServerAddress] can identify various Server instances; in order to 
   * ensure that all requests related to a session are issued to the same Server instance, the Server can answer
   * to the session opening request by providing an address which uniquely identifies its own instance. <BR> 
   * Setting this value to true permits to ignore that address and to always connect through the address 
   * supplied in setServerAddress. This may be needed in a test environment, if the Server address specified 
   * is actually a local address to a specific Server instance in the cluster. <BR>
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** false.
   * 
   * **Lifecycle** This method can be called at any time. If called while connected, it will be applied when the 
   * next session creation request is issued.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverInstanceAddressIgnored" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true or false, to ignore or not the server instance address sent by the server.
   * 
   * - See [ConnectionDetails.setServerAddress]
   */
  void setServerInstanceAddressIgnored(bool newVal) {
    _serverInstanceAddressIgnored = newVal;
  }

  /**
   * Inquiry method that checks if the slowing algorithm is enabled or not.
   *
   * **Returns** Whether the slowing algorithm is enabled or not.
   * - See [setSlowingEnabled]
   */
  bool isSlowingEnabled() {
    return _slowingEnabled;
  }

  /**
   * Setter method that turns on or off the slowing algorithm. 
   * 
   * This heuristic algorithm tries to detect when the client 
   * CPU is not able to keep the pace of the events sent by the Server on a streaming connection. In that case, an automatic
   * transition to polling is performed. <BR>
   * In polling, the client handles all the data before issuing the next poll, hence a slow client would just delay the polls, 
   * while the Server accumulates and merges the events and ensures that no obsolete data is sent. <BR>
   * Only in very slow clients, the next polling request may be so much delayed that the Server disposes the session first, 
   * because of its protection timeouts. In this case, a request for a fresh session will be reissued by the client and this 
   * may happen in cycle.
   * 
   * **Default** false.
   * 
   * **Lifecycle** This setting should be performed before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will 
   * be used for the next streaming connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "slowingEnabled" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true or false, to enable or disable the heuristic algorithm that lowers the item update frequency.
   */
  void setSlowingEnabled(bool newVal) {
    _slowingEnabled = newVal;
  }

  Future<T> _invokeMethod<T>(String method, [ Map<String, dynamic>? arguments ]) async {
    arguments = arguments ?? {};
    arguments["id"] = _id;
    return await NativeBridge.instance.invokeMethod('ConnectionOptions.$method', arguments);
  }
}

/**
  * Class representing a Subscription to be submitted to a Lightstreamer Server. 
  *
  * It contains subscription details and the listeners needed to process the real-time data. <BR>
  * After the creation, a Subscription object is in the "inactive" state. When a Subscription 
  * object is subscribed to on a LightstreamerClient object, through the 
  * [LightstreamerClient.subscribe] method, its state becomes "active". 
  * This means that the client activates a subscription to the required items through 
  * Lightstreamer Server and the Subscription object begins to receive real-time events. <BR>
  * A Subscription can be configured to use either an Item Group or an Item List to specify the 
  * items to be subscribed to and using either a Field Schema or Field List to specify the fields. <BR>
  * "Item Group" and "Item List" are defined as follows:
  * <ul>
  *  <li>"Item Group": an Item Group is a String identifier representing a list of items. 
  *  Such Item Group has to be expanded into a list of items by the getItems method of the 
  *  MetadataProvider of the associated Adapter Set. When using an Item Group, items in the 
  *  subscription are identified by their 1-based index within the group.<BR>
  *  It is possible to configure the Subscription to use an "Item Group" using the 
  *  [setItemGroup] method.</li> 
  *  <li>"Item List": an Item List is an array of Strings each one representing an item. 
  *  For the Item List to be correctly interpreted a LiteralBasedProvider or a MetadataProvider 
  *  with a compatible implementation of getItems has to be configured in the associated 
  *  Adapter Set.<BR>
  *  Note that no item in the list can be empty, can contain spaces or can be a number.<BR>
  *  When using an Item List, items in the subscription are identified by their name or 
  *  by their 1-based index within the list.<BR>
  *  It is possible to configure the Subscription to use an "Item List" using the 
  *  [setItems] method or by specifying it in the constructor.</li>
  * </ul>
  * "Field Schema" and "Field List" are defined as follows:
  * <ul>
  *  <li>"Field Schema": a Field Schema is a String identifier representing a list of fields. 
  *  Such Field Schema has to be expanded into a list of fields by the getFields method of 
  *  the MetadataProvider of the associated Adapter Set. When using a Field Schema, fields 
  *  in the subscription are identified by their 1-based index within the schema.<BR>
  *  It is possible to configure the Subscription to use a "Field Schema" using the 
  *  [setFieldSchema] method.</li>
  *  <li>"Field List": a Field List is an array of Strings each one representing a field. 
  *  For the Field List to be correctly interpreted a LiteralBasedProvider or a MetadataProvider 
  *  with a compatible implementation of getFields has to be configured in the associated 
  *  Adapter Set.<BR>
  *  Note that no field in the list can be empty or can contain spaces.<BR>
  *  When using a Field List, fields in the subscription are identified by their name or 
  *  by their 1-based index within the list.<BR>
  *  It is possible to configure the Subscription to use a "Field List" using the 
  *  [setFields] method or by specifying it in the constructor.</li>
  * </ul>
  */
class Subscription {
  static int _idGenerator = 0;
  final String _id;

  final List<SubscriptionListener> _listeners = [];
  final String _mode;
  List<String>? _items;
  List<String>? _fields;
  String? _group;
  String? _schema;
  String? _dataAdapter;
  String? _bufferSize;
  String? _snapshot;
  String? _requestedMaxFrequency;
  String? _selector;
  String? _dataAdapter2;
  List<String>? _fields2;
  String? _schema2;

  // _active is true when the subscribe method has been called and the unsubscribe method has not been called in the meantime;
  // _active is false when the unsubscribe method has been called and the subscribe method has not been called in the meantime
  bool _active = false;
  bool _subscribed = false;
  int? _commandPosition;
  int? _keyPosition;
  // _remoteActive is true iff the remote image of this subscription has been created,
  // i.e. `LightstreamerClient.subscribe` has been called with this Subscription as an argument
  bool _remoteActive = false;

  Map<String, dynamic> _toMap() {
    return {
      'id': _id,
      'mode': _mode,
      'items': _items,
      'fields': _fields,
      'group': _group,
      'schema': _schema,
      'dataAdapter': _dataAdapter,
      'bufferSize': _bufferSize,
      'snapshot': _snapshot,
      'requestedMaxFrequency': _requestedMaxFrequency,
      'selector': _selector,
      'dataAdapter2': _dataAdapter2,
      'fields2': _fields2,
      'schema2': _schema2,
    };
  }

  /**
   * Creates an object to be used to describe a Subscription that is going to be subscribed to 
   * through Lightstreamer Server. 
   * 
   * The object can be supplied to 
   * [LightstreamerClient.subscribe] and 
   * [LightstreamerClient.unsubscribe], in order to bring the Subscription 
   * to "active" or back to "inactive" state. <BR>
   * Note that all of the methods used to describe the subscription to the server can only be 
   * called while the instance is in the "inactive" state; the only exception is 
   * [setRequestedMaxFrequency].
   *
   * - [mode] the subscription mode for the items, required by Lightstreamer Server. 
   * Permitted values are:
   * <ul>
   *  <li>MERGE</li>
   *  <li>DISTINCT</li>
   *  <li>RAW</li>
   *  <li>COMMAND</li>
   * </ul>
   * - [items] an array of items to be subscribed to through Lightstreamer server. <BR>
   * It is also possible specify the "Item List" or "Item Group" later through 
   * [setItems] and [setItemGroup].
   * - [fields] an array of fields for the items to be subscribed to through Lightstreamer Server. <BR>
   * It is also possible to specify the "Field List" or "Field Schema" later through 
   * [setFields] and [setFieldSchema].
   * 
   * **Throws** IllegalArgumentException If no or invalid subscription mode is passed.
   * 
   * **Throws** IllegalArgumentException If either the items or the fields array is left null.
   * 
   * **Throws** IllegalArgumentException If the specified "Item List" or "Field List" is not valid; 
   * see [setItems] and [setFields] for details.
   */
  Subscription(String mode, [ List<String>? items, List<String>? fields ]) : 
    _id = 'sub${_idGenerator++}',
    _mode = mode, 
    _items = items?.toList(), 
    _fields = fields?.toList();

  /**
   * Adds a listener that will receive events from the Subscription instance.
   * 
   * The same listener can be added to several different Subscription instances.
   *
   * **Lifecycle** A listener can be added at any time. A call to add a listener already 
   * present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the 
   * SubscriptionListener interface.
   * 
   * - See [removeListener]
   */
  void addListener(SubscriptionListener listener) {
    if (!_listeners.contains(listener)) {
      _listeners.add(listener);
      scheduleMicrotask(() {
        listener.onListenStart();
      });
    }
  }

  /**
   * Removes a listener from the Subscription instance so that it will not receive 
   * events anymore.
   * 
   * **Lifecycle** a listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(SubscriptionListener listener) {
    var found = _listeners.remove(listener);
    if (found) {
      scheduleMicrotask(() {
        listener.onListenEnd();
      });
    }
  }

 /**
  * Returns a list containing the [SubscriptionListener] instances that were 
  * added to this client.
  *
  * **Returns** a list containing the listeners that were added to this client. 
  * - See [addListener]
  */
  List<SubscriptionListener> getListeners() {
    return _listeners.toList();
  }

  /**
   * Returns the position of the "command" field in a COMMAND Subscription.
   * 
   * This method can only be used if the Subscription mode is COMMAND and the Subscription 
   * was initialized using a "Field Schema".
   *
   * **Lifecycle** This method can be called at any time after the first 
   * [SubscriptionListener.onSubscription] event.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND or if the 
   * [SubscriptionListener.onSubscription] event for this Subscription was not 
   * yet fired.
   * 
   * **Throws** IllegalStateException if a "Field List" was specified.
   * 
   * **Returns** the 1-based position of the "command" field within the "Field Schema".
   */
  int? getCommandPosition() {
    return _commandPosition;
  }
  /**
   * Returns the position of the "key" field in a COMMAND Subscription.
   * 
   * This method can only be used if the Subscription mode is COMMAND
   * and the Subscription was initialized using a "Field Schema".
   *  
   * **Lifecycle** This method can be called at any time.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not 
   * COMMAND or if the [SubscriptionListener.onSubscription] event for this Subscription
   * was not yet fired.
   * 
   * **Returns** the 1-based position of the "key" field within the "Field Schema".
   */
  int? getKeyPosition() {
    return _keyPosition;
  }
  /**
   * Inquiry method that can be used to read the second-level Data Adapter name configured 
   * through [setCommandSecondLevelDataAdapter].
   *
   * **Lifecycle** This method can be called at any time.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the name of the second-level Data Adapter.
   * - See [setCommandSecondLevelDataAdapter]
   */
  String? getCommandSecondLevelDataAdapter() {
    return _dataAdapter2;
  }
  /**
   * Setter method that sets the name of the second-level Data Adapter (within 
   * the Adapter Set used by the current session) that supplies all the 
   * second-level items.
   * 
   * All the possible second-level items should be supplied in "MERGE" mode 
   * with snapshot available. <BR> 
   * The Data Adapter name is configured on the server side through the 
   * "name" attribute of the &lt;data_provider&gt; element, in the "adapters.xml" 
   * file that defines the Adapter Set (a missing attribute configures the 
   * "DEFAULT" name).
   * 
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   *
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   *
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   *  
   * - See [Subscription.setCommandSecondLevelFields]
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  void setCommandSecondLevelDataAdapter(String? dataAdapter) {
    _dataAdapter2 = dataAdapter;
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for second-level 
   * Subscriptions.
   *
   * **Lifecycle** This method can only be called if the second-level of this Subscription 
   * has been initialized using a "Field List"
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the list of fields to be subscribed to through the server, or null if the Subscription was initialized with a "Field Schema" or was not initialized at all.
   * - See [Subscription.setCommandSecondLevelFields]
   */
  List<String>? getCommandSecondLevelFields() {
    return _fields2?.toList();
  }
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server for the second-level items. 
   *
   * It can only be used on COMMAND Subscriptions. <BR>
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified for the second-level. <BR>
   * Calling this method enables the two-level behavior:<BR>
   * in synthesis, each time a new key is received on the COMMAND Subscription, 
   * the key value is treated as an Item name and an underlying Subscription for
   * this Item is created and subscribed to automatically, to feed fields specified
   * by this method. This mono-item Subscription is specified through an "Item List"
   * containing only the Item name received. As a consequence, all the conditions
   * provided for subscriptions through Item Lists have to be satisfied. The item is 
   * subscribed to in "MERGE" mode, with snapshot request and with the same maximum
   * frequency setting as for the first-level items (including the "unfiltered" 
   * case). All other Subscription properties are left as the default. When the 
   * key is deleted by a DELETE command on the first-level Subscription, the 
   * associated second-level Subscription is also unsubscribed from. <BR> 
   * Specifying null as parameter will disable the two-level behavior.
   *       
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalArgumentException if any of the field names in the "Field List"
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   * 
   * - [fields] An array of Strings containing a list of fields to
   * be subscribed to through the server. <BR>
   * Ensure that no name conflict is generated between first-level and second-level
   * fields. In case of conflict, the second-level field will not be accessible
   * by name, but only by position.
   * 
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  void setCommandSecondLevelFields(List<String>? fields) {
    _fields2 = fields?.toList();
  }
  /**
   * Inquiry method that can be used to read the "Field Schema" specified for second-level 
   * Subscriptions.
   *
   * **Lifecycle** This method can only be called if the second-level of this Subscription has 
   * been initialized using a "Field Schema".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the Subscription was initialized with a "Field List" or was not initialized at all.
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  String? getCommandSecondLevelFieldSchema() {
    return _schema2;
  }
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server for the second-level items. 
   *
   * It can only be used on COMMAND Subscriptions. <BR>
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified for the second-level. <BR>
   * Calling this method enables the two-level behavior:<BR>
   * in synthesis, each time a new key is received on the COMMAND Subscription, 
   * the key value is treated as an Item name and an underlying Subscription for
   * this Item is created and subscribed to automatically, to feed fields specified
   * by this method. This mono-item Subscription is specified through an "Item List"
   * containing only the Item name received. As a consequence, all the conditions
   * provided for subscriptions through Item Lists have to be satisfied. The item is 
   * subscribed to in "MERGE" mode, with snapshot request and with the same maximum
   * frequency setting as for the first-level items (including the "unfiltered" 
   * case). All other Subscription properties are left as the default. When the 
   * key is deleted by a DELETE command on the first-level Subscription, the 
   * associated second-level Subscription is also unsubscribed from. <BR>
   * Specify null as parameter will disable the two-level behavior.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   * 
   * - See [Subscription.setCommandSecondLevelFields]
   */
  void setCommandSecondLevelFieldSchema(String? schemaName) {
    _schema2 = schemaName;
  }
  /**
   * Inquiry method that can be used to read the name of the Data Adapter specified for this 
   * Subscription through [setDataAdapter].
   
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the Data Adapter; returns null if no name has been configured, 
   * so that the "DEFAULT" Adapter Set is used.
   */
  String? getDataAdapter() {
    return _dataAdapter;
  }
  /**
   * Setter method that sets the name of the Data Adapter
   * (within the Adapter Set used by the current session)
   * that supplies all the items for this Subscription.
   *
   * The Data Adapter name is configured on the server side through
   * the "name" attribute of the "data_provider" element, in the
   * "adapters.xml" file that defines the Adapter Set (a missing attribute
   * configures the "DEFAULT" name). <BR>
   * Note that if more than one Data Adapter is needed to supply all the
   * items in a set of items, then it is not possible to group all the
   * items of the set in a single Subscription. Multiple Subscriptions
   * have to be defined.
   *
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   *  
   * - See [ConnectionDetails.setAdapterSet]
   */
  void setDataAdapter(String? dataAdapter) {
    _dataAdapter = dataAdapter;
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for this Subscription.
   *
   * **Lifecycle**  This method can only be called if the Subscription has been initialized 
   * using a "Field List".
   * 
   * **Returns** the "Field List" to be subscribed to through the server, or null if the Subscription was initialized with a "Field Schema" or was not initialized at all.
   */
  List<String>? getFields() {
    return _fields?.toList();
  }
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalArgumentException if any of the field names in the list
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [fields] an array of fields to be subscribed to through the server. 
   */
  void setFields(List<String>? fields) {
    _fields = fields?.toList();
  }
  /**
   * Inquiry method that can be used to read the field schema specified for this Subscription.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized 
   * using a "Field Schema"
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the Subscription was initialized with a "Field List" or was not initialized at all.
   */
  String? getFieldSchema() {
    return _schema;
  }
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   */
  void setFieldSchema(String? schemaName) {
    _schema = schemaName;
  }
  /**
   * Inquiry method that can be used to read the item group specified for this Subscription.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized
   * using an "Item Group"
   * 
   * **Returns** the "Item Group" to be subscribed to through the server, or null if the Subscription was initialized with an "Item List" or was not initialized at all.
   */
  String? getItemGroup() {
    return _group;
  }
  /**
   * Setter method that sets the "Item Group" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [groupName] A String to be expanded into an item list by the
   * Metadata Adapter. 
   */
  void setItemGroup(String? groupName) {
    _group = groupName;
  }
  /**
   * Inquiry method that can be used to read the "Item List" specified for this Subscription. 
   *
   * Note that if the single-item-constructor was used, this method will return an array 
   * of length 1 containing such item.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized 
   * with an "Item List".
   * 
   * **Returns** the "Item List" to be subscribed to through the server, or null if the Subscription was initialized with an "Item Group" or was not initialized at all.
   */
  List<String>? getItems() {
    return _items?.toList();
  }
   /**
    * Setter method that sets the "Item List" to be subscribed to through 
    * Lightstreamer Server.
    *
    * Any call to this method will override any "Item List" or "Item Group"
    * previously specified.
    * 
    * **Lifecycle** This method can only be called while the Subscription
    * instance is in its "inactive" state.
    * 
    * **Throws** IllegalArgumentException if any of the item names in the "Item List"
    * contains a space or is a number or is empty/null.
    *
    * **Throws** IllegalStateException if the Subscription is currently 
    * "active".
    * 
    * - [items] an array of items to be subscribed to through the server. 
    */
  void setItems(List<String>? items) {
    _items = items?.toList();
  }
   /**
    * Inquiry method that can be used to read the mode specified for this
    * Subscription.
    * 
    * **Lifecycle** This method can be called at any time.
    * 
    * **Returns** the Subscription mode specified in the constructor.
    */
  String getMode() {
    return _mode;
  }
  /**
   * Inquiry method that can be used to read the buffer size, configured though
   * [setRequestedBufferSize], to be requested to the Server for 
   * this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  An integer number, representing the buffer size to be requested to the server,
   * or the string "unlimited", or null.
   */
  String? getRequestedBufferSize() {
    return _bufferSize;
  }
  /**
   * Setter method that sets the length to be requested to Lightstreamer
   * Server for the internal queuing buffers for the items in the Subscription.
   *
   * A Queuing buffer is used by the Server to accumulate a burst
   * of updates for an item, so that they can all be sent to the client,
   * despite of bandwidth or frequency limits. It can be used only when the
   * subscription mode is MERGE or DISTINCT and unfiltered dispatching has
   * not been requested. Note that the Server may pose an upper limit on the
   * size of its internal buffers.
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This means that the buffer size will be 1 for MERGE 
   * subscriptions and "unlimited" for DISTINCT subscriptions. See 
   * the "General Concepts" document for further details.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor "unlimited" nor a valid positive integer number.
   *
   * - [size]  An integer number, representing the length of the internal queuing buffers
   * to be used in the Server. If the string "unlimited" is supplied, then no buffer
   * size limit is requested (the check is case insensitive). It is also possible
   * to supply a null value to stick to the Server default (which currently
   * depends on the subscription mode).
   *
   * - See [Subscription.setRequestedMaxFrequency]
   */
  void setRequestedBufferSize(String? size) {
    _bufferSize = size;
  }
  /**
   * Inquiry method that can be used to read the max frequency, configured
   * through [setRequestedMaxFrequency], to be requested to the 
   * Server for this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  A decimal number, representing the max frequency to be requested to the server
   * (expressed in updates per second), or the strings "unlimited" or "unfiltered", or null.
   */
  String? getRequestedMaxFrequency() {
    return _requestedMaxFrequency;
  }
  /**
   * Setter method that sets the maximum update frequency to be requested to
   * Lightstreamer Server for all the items in the Subscription. 
   *
   * It can be used only if the Subscription mode is MERGE, DISTINCT or
   * COMMAND (in the latter case, the frequency limitation applies to the
   * UPDATE events for each single key). For Subscriptions with two-level behavior
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , the specified frequency limit applies to both first-level and second-level items. <BR>
   * Note that frequency limits on the items can also be set on the
   * server side and this request can only be issued in order to further
   * reduce the frequency, not to rise it beyond these limits. <BR>
   * This method can also be used to request unfiltered dispatching
   * for the items in the Subscription. However, unfiltered dispatching
   * requests may be refused if any frequency limit is posed on the server
   * side for some item.
   *
   * **General Edition Note** A further global frequency limit could also be imposed by the Server,
   * depending on Edition and License Type; this specific limit also applies to RAW mode and
   * to unfiltered dispatching.
   * To know what features are enabled by your license, please see the License tab of the
   * Monitoring Dashboard (by default, available at /dashboard).
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This consists, for all modes, in not applying any frequency 
   * limit to the subscription (the same as "unlimited"); see the "General Concepts"
   * document for further details.
   *
   * **Lifecycle** This method can can be called at any time with some
   * differences based on the Subscription status:
   * <ul>
   * <li>If the Subscription instance is in its "inactive" state then
   * this method can be called at will.</li>
   * <li>If the Subscription instance is in its "active" state then the method
   * can still be called unless the current value is "unfiltered" or the
   * supplied value is "unfiltered" or null.
   * If the Subscription instance is in its "active" state and the
   * connection to the server is currently open, then a request
   * to change the frequency of the Subscription on the fly is sent to the server.</li>
   * </ul>
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active" and the current value of this property is "unfiltered".
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active" and the given parameter is null or "unfiltered".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor one of the special "unlimited" and "unfiltered" values nor
   * a valid positive number.
   *
   * - [freq]  A decimal number, representing the maximum update frequency (expressed in updates
   * per second) for each item in the Subscription; for instance, with a setting
   * of 0.5, for each single item, no more than one update every 2 seconds
   * will be received. If the string "unlimited" is supplied, then no frequency
   * limit is requested. It is also possible to supply the string 
   * "unfiltered", to ask for unfiltered dispatching, if it is allowed for the 
   * items, or a null value to stick to the Server default (which currently
   * corresponds to "unlimited").
   * The check for the string constants is case insensitive.
   */
  Future<void> setRequestedMaxFrequency(String? freq) async {
    _requestedMaxFrequency = freq;
    if (_remoteActive) {
      var arguments = <String, dynamic> {
        'newVal': freq
      };
      return await _invokeMethod('setRequestedMaxFrequency', arguments);
    }
  }
  /**
   * Inquiry method that can be used to read the snapshot preferences, 
   * configured through [setRequestedSnapshot], to be requested 
   * to the Server for this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  "yes", "no", null, or an integer number.
   */
  String? getRequestedSnapshot() {
    return _snapshot;
  }
  /**
   * Setter method that enables/disables snapshot delivery request for the
   * items in the Subscription. 
   *
   * The snapshot can be requested only if the
   * Subscription mode is MERGE, DISTINCT or COMMAND.
   *
   * **Default** "yes" if the Subscription mode is not "RAW",
   * null otherwise.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * "yes" nor "no" nor null nor a valid integer positive number.
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * compatible with the mode of the Subscription: 
   * <ul>
   *  <li>In case of a RAW Subscription only null is a valid value;</li>
   *  <li>In case of a non-DISTINCT Subscription only null "yes" and "no" are
   *  valid values.</li>
   * </ul>
   *
   * - [required] "yes"/"no" to request/not request snapshot
   * delivery (the check is case insensitive). If the Subscription mode is 
   * DISTINCT, instead of "yes", it is also possible to supply an integer number, 
   * to specify the requested length of the snapshot (though the length of 
   * the received snapshot may be less than requested, because of insufficient 
   * data or server side limits);
   * passing "yes"  means that the snapshot length should be determined
   * only by the Server. Null is also a valid value; if specified, no snapshot 
   * preference will be sent to the server that will decide itself whether
   * or not to send any snapshot. 
   * 
   * - See [ItemUpdate.isSnapshot]
   */
  void setRequestedSnapshot(String? isRequired) {
    _snapshot = isRequired;
  }
  /**
   * Inquiry method that can be used to read the selector name  
   * specified for this Subscription through [setSelector].
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the selector.
   */
  String? getSelector() {
    return _selector;
  }
  /**
   * Setter method that sets the selector name for all the items in the
   * Subscription. The selector is a filter on the updates received.
   *
   * It is executed on the Server and implemented by the Metadata Adapter.
   *
   * **Default** null (no selector).
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - [selector] name of a selector, to be recognized by the
   * Metadata Adapter, or null to unset the selector.
   */
  void setSelector(String? selector) {
    _selector = selector;
  }
  /**  
   * Inquiry method that checks if the Subscription is currently "active" or not.
   *
   * Most of the Subscription properties cannot be modified if a Subscription 
   * is "active". <BR>
   * The status of a Subscription is changed to "active" through the  
   * [LightstreamerClient.subscribe] method and back to 
   * "inactive" through the [LightstreamerClient.unsubscribe] one.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true/false if the Subscription is "active" or not.
   * 
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   */
  bool isActive() {
    return _active;
  }
  /**  
   * Inquiry method that checks if the Subscription is currently subscribed to
   * through the server or not.
   *
   * This flag is switched to true by server sent Subscription events, and 
   * back to false in case of client disconnection, 
   * [LightstreamerClient.unsubscribe] calls and server 
   * sent unsubscription events. 
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true/false if the Subscription is subscribed to
   * through the server or not.
   */
  bool isSubscribed() {
    return _subscribed;
  }
  
  /**
   * Returns the latest value received for the specified item/field pair.
   *
   * It is suggested to consume real-time data by implementing and adding
   * a proper [SubscriptionListener] rather than probing this method. <BR>
   * In case of COMMAND Subscriptions, the value returned by this
   * method may be misleading, as in COMMAND mode all the keys received, being
   * part of the same item, will overwrite each other; for COMMAND Subscriptions,
   * use [getCommandValue] instead. <BR>
   * Note that internal data is cleared when the Subscription is 
   * unsubscribed from.
   *
   * **Lifecycle** This method can be called at any time; if called 
   * to retrieve a value that has not been received yet, then it will return null. 
   * 
   * **Throws** IllegalArgumentException if an invalid item name or field name is specified.
   * - [itemNameOrPosition] an item in the configured "Item List" or the 1-based position of an item within the configured "Item Group" or "Item List"
   * - [fieldNameOrPosition] a item in the configured "Field List" or the 1-based position of a field within the configured "Field Schema" or "Field List"
   * 
   * **Returns** the current value for the specified field of the specified item
   * (possibly null), or null if no value has been received yet.
   */
  Future<String?> getValue(String itemNameOrPosition, String fieldNameOrPosition) async {
    if (!_remoteActive) {
      return null;
    }
    var itemPos = int.tryParse(itemNameOrPosition, radix: 10);
    var fieldPos = int.tryParse(fieldNameOrPosition, radix: 10);
    var itemName = itemNameOrPosition;
    var fieldName = fieldNameOrPosition;
    if (itemPos == null) {
      if (fieldPos == null) {
        var arguments = <String, dynamic> {
          'item': itemName,
          'field': fieldName,
        };
        return await _invokeMethod('getValueByItemNameAndFieldName', arguments);
      } else {
        var arguments = <String, dynamic> {
          'item': itemName,
          'field': fieldPos,
        };
        return await _invokeMethod('getValueByItemNameAndFieldPos', arguments);
      }
    } else {
      if (fieldPos == null) {
        var arguments = <String, dynamic> {
          'item': itemPos,
          'field': fieldName,
        };
        return await _invokeMethod('getValueByItemPosAndFieldName', arguments);
      } else {
        var arguments = <String, dynamic> {
          'item': itemPos,
          'field': fieldPos,
        };
        return await _invokeMethod('getValueByItemPosAndFieldPos', arguments);
      }
    }
  }
  /**
   * Returns the latest value received for the specified item/key/field combination.
   *  
   * This method can only be used if the Subscription mode is COMMAND. 
   * Subscriptions with two-level behavior
   * are also supported, hence the specified field 
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * can be either a first-level or a second-level one. <BR>
   * It is suggested to consume real-time data by implementing and adding a proper 
   * [SubscriptionListener] rather than probing this method. <BR>
   * Note that internal data is cleared when the Subscription is unsubscribed from.
   *
   * - [itemNameOrPosition] an item in the configured "Item List" or the 1-based position of an item within the configured "Item Group" or "Item List"
   * - [keyValue] the value of a key received on the COMMAND subscription.
   * - [fieldNameOrPosition] a item in the configured "Field List" or the 1-based position of a field within the configured "Field Schema" or "Field List"
   * 
   * **Throws** IllegalArgumentException if an invalid item name or field name is specified.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND.
   * 
   * **Returns** the current value for the specified field of the specified key within the 
   * specified item (possibly null), or null if the specified key has not been added yet 
   * (note that it might have been added and then deleted).
   */
  Future<String?> getCommandValue(String itemNameOrPosition, String keyValue, String fieldNameOrPosition) async {
    if (!_remoteActive) {
      return null;
    }
    var itemPos = int.tryParse(itemNameOrPosition, radix: 10);
    var fieldPos = int.tryParse(fieldNameOrPosition, radix: 10);
    var itemName = itemNameOrPosition;
    var fieldName = fieldNameOrPosition;
    if (itemPos == null) {
      if (fieldPos == null) {
        var arguments = <String, dynamic> {
          'item': itemName,
          'key': keyValue,
          'field': fieldName,
        };
        return await _invokeMethod('getCommandValueByItemNameAndFieldName', arguments);
      } else {
        var arguments = <String, dynamic> {
          'item': itemName,
          'key': keyValue,
          'field': fieldPos,
        };
        return await _invokeMethod('getCommandValueByItemNameAndFieldPos', arguments);
      }
    } else {
      if (fieldPos == null) {
        var arguments = <String, dynamic> {
          'item': itemPos,
          'key': keyValue,
          'field': fieldName,
        };
        return await _invokeMethod('getCommandValueByItemPosAndFieldName', arguments);
      } else {
        var arguments = <String, dynamic> {
          'item': itemPos,
          'key': keyValue,
          'field': fieldPos,
        };
        return await _invokeMethod('getCommandValueByItemPosAndFieldPos', arguments);
      }
    }
  }

  Future<T> _invokeMethod<T>(String method, [ Map<String, dynamic>? arguments ]) async {
    arguments = arguments ?? {};
    arguments["subId"] = _id;
    return await NativeBridge.instance.invokeMethod('Subscription.$method', arguments);
  }
}

/**
 * Class representing a device that supports Mobile Push Notifications (MPN).
 * 
 * It contains device details and the listener needed to monitor its status.<BR>
 * An MPN device is created from the application context, the sender ID (a.k.a. authorized entity) and a device token (a.k.a. registration token) obtained from 
 * Firebase Cloud Messaging APIs, and must be registered on the [LightstreamerClient] in order to successfully subscribe an MPN subscription. 
 * See [MpnSubscription].<BR>
 * After creation, an MpnDevice object is in "unknown" state. It must then be passed to the Lightstreamer Server with the
 * [LightstreamerClient.registerForMpn] method, which enables the client to subscribe MPN subscriptions and sends the device details to the
 * server's MPN Module, where it is assigned a permanent device ID and its state is switched to "registered".<BR>
 * Upon registration on the server, active MPN subscriptions of the device are received and exposed with the [LightstreamerClient.getMpnSubscriptions]
 * method.<BR>
 * An MpnDevice's state may become "suspended" if errors occur during push notification delivery. In this case MPN subscriptions stop sending notifications
 * and the device state is reset to "registered" at the first subsequent registration.
 */
class MpnDevice {
  static int _idGenerator = 0;

  final String _id;
  final List<MpnDeviceListener> _listeners = [];
  String? _applicationId;
  String? _deviceId;
  String? _deviceToken;
  String? _platform;
  String? _previousDeviceToken;
  String _status = 'UNKNOWN';
  int _statusTs = 0;

  MpnDevice() : _id = 'dev${_idGenerator++}';

  /**
   * Adds a listener that will receive events from the MPN device object.
   * 
   * The same listener can be added to several different MPN device objects.<BR>
   * 
   * **Lifecycle** A listener can be added at any time. A call to add a listener already present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the [MpnDeviceListener] interface.
   * 
   * - See [removeListener]
   */
  void addListener(MpnDeviceListener listener) {
    if (!_listeners.contains(listener)) {
      _listeners.add(listener);
      scheduleMicrotask(() {
        listener.onListenStart();
      });
    }
  }

  /**
   * Removes a listener from the MPN device object so that it will not receive events anymore.
   * 
   * **Lifecycle** A listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(MpnDeviceListener listener) {
    var found = _listeners.remove(listener);
    if (found) {
      scheduleMicrotask(() {
        listener.onListenEnd();
      });
    }
  }

  /**
   * List containing the [MpnDeviceListener] instances that were added to this MPN device object.
   * 
   * **Returns** a list containing the listeners that were added to this device.
   * 
   * - See [addListener]
   */
  List<MpnDeviceListener> getListeners() {
    return _listeners.toList();
  }

  /**
   * The application ID of this MPN device, corresponding to the package name of the application. In the [MpnDevice]
   * implementation it is determined automatically from the Application Context during creation and is used by the server as part of the device identification.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device application ID.
   */
  String? getApplicationId() {
    return _applicationId;
  }

  /**
   * The server-side unique persistent ID of the device.
   * 
   * The ID is available only after the MPN device object has been successfully registered on the server. I.e. when its status is <code>REGISTERED</code> or
   * <code>SUSPENDED</code>.<BR>
   * Note: a device token change, if the previous device token was correctly stored on the Shared Preferences storage, does not cause the device ID to change: the
   * server moves previous MPN subscriptions from the previous token to the new one and the device ID remains unaltered.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device ID.
   */
  String? getDeviceId() {
    return _deviceId;
  }

  /**
   * The device token of this MPN device. 
   * 
   * In the [MpnDevice] implementation it is passed during creation and 
   * is used by the server as part of the device identification.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device token.
   */
  String? getDeviceToken() {
    return _deviceToken;
  }

  /**
   * The platform identifier of this MPN device. 
   * 
   * In the [MpnDevice] implementation it equals to the constant <code>Google</code>
   * and is used by the server as part of the device identification.
   *  
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device platform.
   */
  String? getPlatform() {
    return _platform;
  }

  /**
   * The previous device token of this MPN device. 
   * 
   * In the [MpnDevice] implementation it is obtained automatically from 
   * the Shared Preferences storage during creation and is used by the server to restore MPN subscriptions associated with this previous token. May be null if 
   * no MPN device has been registered yet on the application.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the previous MPN device token, or null if no MPN device has been registered yet.
   */
  String? getPreviousDeviceToken() {
    return _previousDeviceToken;
  }

  /**
   * The status of the device.
   * 
   * The status can be:<ul>
   * <li><code>UNKNOWN</code>: when the MPN device object has just been created or deleted. In this status [isRegistered] and [isSuspended] are both false.</li>
   * <li><code>REGISTERED</code>: when the MPN device object has been successfully registered on the server. In this status [isRegistered] is true and
   * [isSuspended] is false.</li>
   * <li><code>SUSPENDED</code>: when a server error occurred while sending push notifications to this MPN device and consequently it has been suspended. In this status 
   * [isRegistered] and [isSuspended] are both true.</li>
   * </ul>
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the status of the device.
   * 
   * - See [isRegistered]
   * - See [isSuspended]
   */
  String getStatus() {
    return _status;
  }

  /**
   * The server-side timestamp of the device status.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** The server-side timestamp of the device status.
   * 
   * - See [getStatus]
   */
  int getStatusTimestamp() {
    return _statusTs;
  }

  /**
   * Checks whether the MPN device object is currently registered on the server or not.
   * 
   * This flag is switched to true by server sent registration events, and back to false in case of client disconnection or server sent suspension events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MPN device object is currently registered on the server.
   * 
   * - See [getStatus]
   */
  bool isRegistered() {
    return _status != 'UNKNOWN';
  }

  /**
   * Checks whether the MPN device object is currently suspended on the server or not.
   * 
   * An MPN device may be suspended if errors occur during push notification delivery.<BR>
   * This flag is switched to true by server sent suspension events, and back to false in case of client disconnection or server sent resume events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MPN device object is currently suspended on the server.
   * 
   * - See [getStatus]
   */
  bool isSuspended() {
    return _status == 'SUSPENDED';
  }
}

/**
 * Class representing a Mobile Push Notifications (MPN) subscription to be submitted to the MPN Module of a Lightstreamer Server.
 * 
 * It contains subscription details and the listener needed to monitor its status. Real-time data is routed via native push notifications.<BR>
 * In order to successfully subscribe an MPN subscription, first an MpnDevice must be created and registered on the LightstreamerClient with
 * [LightstreamerClient.registerForMpn].<BR>
 * After creation, an MpnSubscription object is in the "inactive" state. When an MpnSubscription object is subscribed to on an LightstreamerClient
 * object, through the [LightstreamerClient.subscribe] method, its state switches to "active". This means that the subscription request
 * is being sent to the Lightstreamer Server. Once the server accepted the request, it begins to send real-time events via native push notifications and
 * the MpnSubscription object switches to the "subscribed" state.<BR>
 * If a trigger expression is set, the MPN subscription does not send any push notifications until the expression evaluates to true. When this happens,
 * the MPN subscription switches to "triggered" state and a single push notification is sent. Once triggered, no other push notifications are sent.<BR>
 * When an MpnSubscription is subscribed on the server, it acquires a permanent subscription ID that the server later uses to identify the same
 * MPN subscription on subsequent sessions.<BR>
 * An MpnSubscription can be configured to use either an Item Group or an Item List to specify the items to be subscribed to, and using either a Field Schema
 * or Field List to specify the fields. The same rules that apply to [Subscription] apply to MpnSubscription.<BR>
 * An MpnSubscription object can also be provided by the client to represent a pre-existing MPN subscription on the server. In fact, differently than real-time
 * subscriptions, MPN subscriptions are persisted on the server's MPN Module database and survive the session they were created on.<BR>
 * MPN subscriptions are associated with the MPN device, and after the device has been registered the client retrieves pre-existing MPN subscriptions from the
 * server's database and exposes them with the [LightstreamerClient.getMpnSubscriptions] method.
 */
class MpnSubscription {
  static int _idGenerator = 0;
  final String _id;

  final List<MpnSubscriptionListener> _listeners = [];
  String _mode;
  List<String>? _items;
  List<String>? _fields;
  String? _group;
  String? _schema;
  String? _dataAdapter;
  String? _bufferSize;
  String? _requestedMaxFrequency;
  String? _trigger;
  String? _notificationFormat;
  //
  String? _actualNotificationFormat;
  String? _actualTrigger;
  //
  int _statusTs = 0;
  String _status = 'UNKNOWN';
  //
  String? _subscriptionId;
  // _remoteActive is true iff the remote image of this subscription has been created,
  // i.e. `LightstreamerClient.subscribeMpn` has been called with this MpnSubscription as an argument
  bool _remoteActive = false;

  Map<String, dynamic> _toMap() {
    return {
      'id': _id,
      'mode': _mode,
      'items': _items,
      'fields': _fields,
      'group': _group,
      'schema': _schema,
      'dataAdapter': _dataAdapter,
      'bufferSize': _bufferSize,
      'requestedMaxFrequency': _requestedMaxFrequency,
      'trigger': _trigger,
      'notificationFormat': _notificationFormat
    };
  }

  static String _nextMpnSubId() {
    return 'mpnsub${_idGenerator++}';
  }

  /**
   * Creates an object to be used to describe an MPN subscription that is going to be subscribed to through the MPN Module of Lightstreamer Server.
   * 
   * The object can be supplied to [LightstreamerClient.subscribe] in order to bring the MPN subscription to "active" state.<BR>
   * Note that all of the methods used to describe the subscription to the server can only be called while the instance is in the "inactive" state.
   *
   * - [mode] The subscription mode for the items, required by Lightstreamer Server. Permitted values are:<ul>
   * <li><code>MERGE</code></li>
   * <li><code>DISTINCT</code></li>
   * </ul>
   * - [items] An array of items to be subscribed to through Lightstreamer Server. It is also possible specify the "Item List" or
   * "Item Group" later through [setItems] and [setItemGroup].
   * - [fields] An array of fields for the items to be subscribed to through Lightstreamer Server. It is also possible to specify the "Field List" or
   * "Field Schema" later through [setFields] and [setFieldSchema].
   * 
   * **Throws** IllegalArgumentException If no or invalid subscription mode is passed.
   * 
   * **Throws** IllegalArgumentException If either the items or the fields array is left null.
   * 
   * **Throws** IllegalArgumentException If the specified "Item List" or "Field List" is not valid; see [setItems] and [setFields] for details.
   */
  MpnSubscription(String mode, [ List<String>? items, List<String>? fields ]) : 
    _id = _nextMpnSubId(),
    _mode = mode, 
    _items = items?.toList(), 
    _fields = fields?.toList();

  /**
   * Creates an MpnSubscription object copying subscription mode, items, fields and data adapter from the specified real-time subscription.
   * 
   * The object can be supplied to [LightstreamerClient.subscribe] in order to bring the MPN subscription to "active" state.<BR>
   * Note that all of the methods used to describe the subscription to the server, except [setTriggerExpression] and [setNotificationFormat], can only be called while the instance is in the "inactive" state.
   * 
   * - [sub] The Subscription object to copy properties from.
   */
  MpnSubscription.fromSubscription(Subscription sub) :
    _id = _nextMpnSubId(),
    _mode = sub.getMode(),
    _items = sub.getItems()?.toList(),
    _fields = sub.getFields()?.toList(),
    _group = sub.getItemGroup(),
    _schema = sub.getFieldSchema(),
    _dataAdapter = sub.getDataAdapter(),
    _bufferSize = sub.getRequestedBufferSize(),
    _requestedMaxFrequency = sub.getRequestedMaxFrequency();

  /**
   * Creates an MPNSubscription object copying all properties from the specified MPN subscription.
   *
   * The object can be supplied to [LightstreamerClient.subscribe] in order to bring the MPN subscription to "active" state.
   *
   * Note that all of the methods used to describe the subscription to the server, except [setTriggerExpression] and [setNotificationFormat], can only be called while the instance is in the "inactive" state.
   * 
   * - [sub] The MpnSubscription object to copy properties from.
   */
  MpnSubscription.fromMpnSubscription(MpnSubscription sub) :
    _id = _nextMpnSubId(),
    _mode = sub.getMode(),
    _items = sub.getItems()?.toList(),
    _fields = sub.getFields()?.toList(),
    _group = sub.getItemGroup(),
    _schema = sub.getFieldSchema(),
    _dataAdapter = sub.getDataAdapter(),
    _bufferSize = sub.getRequestedBufferSize(),
    _requestedMaxFrequency = sub.getRequestedMaxFrequency(),
    _trigger = sub.getTriggerExpression(),
    _notificationFormat = sub.getNotificationFormat();

  MpnSubscription._fromDTO(Map<String, dynamic> dto) : 
    _id = dto['id'], 
    _mode = dto['mode'] 
  {
    _items = dto['items'];
    _fields = dto['fields'];
    _group = dto['group'];
    _schema = dto['schema'];
    _dataAdapter = dto['dataAdapter'];
    _bufferSize = dto['bufferSize'];
    _requestedMaxFrequency = dto['requestedMaxFrequency'];
    _trigger = dto['trigger'];
    _notificationFormat = dto['notificationFormat'];
    _actualNotificationFormat = dto['actualNotificationFormat'];
    _actualTrigger = dto['actualTrigger'];
    _statusTs = dto['statusTs'];
    _status = dto['status'];
    _subscriptionId = dto['subscriptionId'];
    // `_remoteActive` is set to true because
    // `dto` (returned by `LightstreamerClient.getMpnSubscriptions` or `LightstreamerClient.findMpnSubscription`)
    // represents an MpnSubscription living in the Android/iOS component
    _remoteActive = true;
  }

  /**
   * Adds a listener that will receive events from the MpnSubscription instance.
   * 
   * The same listener can be added to several different MpnSubscription instances.<BR>
   * 
   * **Lifecycle** A listener can be added at any time. A call to add a listener already present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the [MpnSubscriptionListener]  interface.
   * 
   * - See [removeListener]
   */
  void addListener(MpnSubscriptionListener listener) {
    if (!_listeners.contains(listener)) {
      _listeners.add(listener);
      scheduleMicrotask(() {
        listener.onListenStart();
      });
    }
  }

  /**
   * Removes a listener from the MpnSubscription instance so that it will not receive events anymore.
   * 
   * **Lifecycle** A listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(MpnSubscriptionListener listener) {
    var found = _listeners.remove(listener);
    if (found) {
      scheduleMicrotask(() {
        listener.onListenEnd();
      });
    }
  }

  /**
   * Returns the list containing the [MpnSubscriptionListener] instances that were added to this MpnSubscription.
   * 
   * **Returns** a list containing the listeners that were added to this subscription.
   *
   * - See [addListener]
   */
  List<MpnSubscriptionListener> getListeners() {
    return _listeners.toList();
  }

  /**
   * Inquiry method that can be used to read the name of the Data Adapter specified for this 
   * MpnSubscription through [setDataAdapter].
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the Data Adapter; returns null if no name has been configured, 
   * so that the "DEFAULT" Adapter Set is used.
   */
  String? getDataAdapter() {
    return _dataAdapter;
  }
  /**
   * Setter method that sets the name of the Data Adapter
   * (within the Adapter Set used by the current session)
   * that supplies all the items for this MpnSubscription.
   * 
   * The Data Adapter name is configured on the server side through
   * the "name" attribute of the "data_provider" element, in the
   * "adapters.xml" file that defines the Adapter Set (a missing attribute
   * configures the "DEFAULT" name). <BR>
   * Note that if more than one Data Adapter is needed to supply all the
   * items in a set of items, then it is not possible to group all the
   * items of the set in a single MpnSubscription. Multiple MpnSubscriptions
   * have to be defined.
   *
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>adapter</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - See [ConnectionDetails.setAdapterSet]
   */
  void setDataAdapter(String? dataAdapter) {
    _dataAdapter = dataAdapter;
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * fields are always expressed with a "Field Schema"", even if originally the MPN subscription used a "Field List".
   *
   * **Lifecycle**  This method can only be called if the MpnSubscription has been initialized 
   * using a "Field List".
   * 
   * **Returns** the "Field List" to be subscribed to through the server, or null if the MpnSubscription was initialized with a "Field Schema" or was not initialized at all.
   */
  List<String>? getFields() {
    return _fields?.toList();
  }
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>schema</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [fields] an array of fields to be subscribed to through the server. 
   * 
   * **Throws** IllegalArgumentException if any of the field names in the list
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  void setFields(List<String>? fields) {
    _fields = fields?.toList();
  }
  /**
   * Inquiry method that can be used to read the field schema specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * fields are always expressed with a "Field Schema"", even if originally the MPN subscription used a "Field List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized 
   * using a "Field Schema"
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the MpnSubscription was initialized with a "Field List" or was not initialized at all.
   */
  String? getFieldSchema() {
    return _schema;
  }
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>schema</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  void setFieldSchema(String? schemaName) {
    _schema = schemaName;
  }
  /**
   * Inquiry method that can be used to read the item group specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * items are always expressed with an "Item Group"", even if originally the MPN subscription used an "Item List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized
   * using an "Item Group"
   * 
   * **Returns** the "Item Group" to be subscribed to through the server, or null if the MpnSubscription was initialized with an "Item List" or was not initialized at all.
   */
  String? getItemGroup() {
    return _group;
  }
  /**
   * Setter method that sets the "Item Group" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>group</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [groupName] A String to be expanded into an item list by the
   * Metadata Adapter. 
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  void setItemGroup(String? groupName) {
    _group = groupName;
  }
  /**
   * Inquiry method that can be used to read the "Item List" specified for this MpnSubscription.
   * 
   * Note that if the single-item-constructor was used, this method will return an array 
   * of length 1 containing such item.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * items are always expressed with an "Item Group"", even if originally the MPN subscription used an "Item List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized 
   * with an "Item List".
   * 
   * **Returns** the "Item List" to be subscribed to through the server, or null if the MpnSubscription was initialized with an "Item Group" or was not initialized at all.
   */
  List<String>? getItems() {
    return _items?.toList();
  }
  /**
   * Setter method that sets the "Item List" to be subscribed to through 
   * Lightstreamer Server. 
   * 
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>group</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [items] an array of items to be subscribed to through the server. 
   * 
   * **Throws** IllegalArgumentException if any of the item names in the "Item List"
   * contains a space or is a number or is empty/null.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  void setItems(List<String>? items) {
    _items = items?.toList();
  }
  /**
   * Inquiry method that can be used to read the mode specified for this
   * MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MpnSubscription mode specified in the constructor.
   */
  String getMode() {
    return _mode;
  }
  /**
   * Inquiry method that can be used to read the buffer size, configured though
   * [setRequestedBufferSize], to be requested to the Server for 
   * this MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  An integer number, representing the buffer size to be requested to the server,
   * or the string "unlimited", or null.
   */
  String? getRequestedBufferSize() {
    return _bufferSize;
  }
  /**
   * Setter method that sets the length to be requested to Lightstreamer
   * Server for the internal queuing buffers for the items in the MpnSubscription.
   * 
   * A Queuing buffer is used by the Server to accumulate a burst
   * of updates for an item, so that they can all be sent to the client,
   * despite of bandwidth or frequency limits.<BR>
   * Note that the Server may pose an upper limit on the size of its internal buffers.
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This means that the buffer size will be 1 for MERGE 
   * subscriptions and "unlimited" for DISTINCT subscriptions. See 
   * the "General Concepts" document for further details.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>requested_buffer_size</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [size]  An integer number, representing the length of the internal queuing buffers
   * to be used in the Server. If the string "unlimited" is supplied, then no buffer
   * size limit is requested (the check is case insensitive). It is also possible
   * to supply a null value to stick to the Server default (which currently
   * depends on the subscription mode).
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor "unlimited" nor a valid positive integer number.
   *
   * - See [setRequestedMaxFrequency]
   */
  void setRequestedBufferSize(String? size) {
    _bufferSize = size;
  }
  /**
   * Inquiry method that can be used to read the max frequency, configured
   * through [setRequestedMaxFrequency], to be requested to the 
   * Server for this MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  A decimal number, representing the max frequency to be requested to the server
   * (expressed in updates per second), or the string "unlimited", or null.
   */
  String? getRequestedMaxFrequency() {
    return _requestedMaxFrequency;
  }
  /**
   * Setter method that sets the maximum update frequency to be requested to
   * Lightstreamer Server for all the items in the MpnSubscription.
   * 
   * Note that frequency limits on the items can also be set on the
   * server side and this request can only be issued in order to further
   * reduce the frequency, not to rise it beyond these limits.
   *
   * **General Edition Note** A further global frequency limit could also be imposed by the Server,
   * depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the
   * Monitoring Dashboard (by default, available at /dashboard).
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This consists, for all modes, in not applying any frequency 
   * limit to the subscription (the same as "unlimited"); see the "General Concepts"
   * document for further details.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>requested_max_frequency</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [freq]  A decimal number, representing the maximum update frequency (expressed in updates
   * per second) for each item in the Subscription; for instance, with a setting
   * of 0.5, for each single item, no more than one update every 2 seconds
   * will be received. If the string "unlimited" is supplied, then no frequency
   * limit is requested. It is also possible to supply the null value to stick 
   * to the Server default (which currently corresponds to "unlimited").
   * The check for the string constants is case insensitive.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor the special "unlimited" value nor a valid positive number.
   */
  void setRequestedMaxFrequency(String? freq) {
    _requestedMaxFrequency = freq;
  }
  /**
   * Inquiry method that gets the trigger expression requested by the user.
   * 
   * **Returns** returns the trigger requested by the user or null if the value is not available.
   * 
   * - See [setTriggerExpression]
   * - See [getActualTriggerExpression]
   */
  String? getTriggerExpression() {
    return _trigger;
  }
  /**
   * Sets the boolean expression that will be evaluated against each update and will act as a trigger to deliver the push notification.
   * 
   * If a trigger expression is set, the MPN subscription does not send any push notifications until the expression evaluates to true. When this happens,
   * the MPN subscription "triggers" and a single push notification is sent. Once triggered, no other push notifications are sent. In other words, with a trigger
   * expression set, the MPN subscription sends *at most one* push notification.<BR>
   * The expression must be in Java syntax and can contain named arguments with the format <code>${field}</code>, or indexed arguments with the format `$[1]`.
   * The same rules that apply to [setNotificationFormat] apply also to the trigger expression. The expression is verified and evaluated on the server.<BR>
   * Named and indexed arguments are replaced by the server with the value of corresponding subscription fields before the expression is evaluated. They are
   * represented as String variables, and as such appropriate type conversion must be considered. E.g.<ul>
   * <li><code>Double.parseDouble(${last_price}) &gt; 500.0</code></li>
   * </ul>
   * Argument variables are named with the prefix <code>LS_MPN_field</code> followed by an index. Thus, variable names like <code>LS_MPN_field1</code> should be considered
   * reserved and their use avoided in the expression.<BR>
   * Consider potential impact on server performance when writing trigger expressions. Since Java code may use classes and methods of the JDK, a badly written
   * trigger may cause CPU hogging or memory exhaustion. For this reason, a server-side filter may be applied to refuse poorly written (or even
   * maliciously crafted) trigger expressions. See the "General Concepts" document for more information.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * named arguments are always mapped to its corresponding indexed argument, even if originally the trigger expression used a named argument.<BR>
   * Note: the content of this property may be subject to length restrictions (See the "General Concepts" document for more information).
   * 
   * **Lifecycle** This property can be changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>trigger</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [trigger] the boolean expression that acts as a trigger to deliver the push notification. If the value is null, no trigger is set on the subscription.
   * 
   * - See [isTriggered]
   */
  Future<void> setTriggerExpression(String? trigger) async {
    _trigger = trigger;
    if (_remoteActive) {
      var arguments = <String, dynamic> {
        'trigger': trigger
      };
      return await _invokeMethod('setTriggerExpression', arguments);
    }
  }
  /**
   * Inquiry method that gets the JSON structure requested by the user to be used as the format of push notifications.
   * 
   * **Returns** the JSON structure requested by the user to be used as the format of push notifications.
   * 
   * - See [setNotificationFormat]
   * - See [getActualNotificationFormat]
   */
  String? getNotificationFormat() {
    return _notificationFormat;
  }
  /**
   * Sets the JSON structure to be used as the format of push notifications.
   * 
   * This JSON structure is sent by the server to the push notification service provider (i.e. Google's FCM), hence it must follow
   * its specifications.<BR>
   * The JSON structure may contain named arguments with the format <code>${field}</code>, or indexed arguments with the format `$[1]`. These arguments are 
   * replaced by the server with the value of corresponding subscription fields before the push notification is sent.<BR>
   * For instance, if the subscription contains fields "stock_name" and "last_price", the notification format could be something like this:<ul>
   * <li><code>{ "android" : { "notification" : { "body" : "Stock ${stock_name} is now valued ${last_price}" } } }</code></li>
   * </ul>
   * Named arguments are available if the Metadata Adapter is a subclass of LiteralBasedProvider or provides equivalent functionality, otherwise only
   * indexed arguments may be used. In both cases common metadata rules apply: field names and indexes are checked against the Metadata Adapter, hence
   * they must be consistent with the schema and group specified.<BR>
   * A special server-managed argument may also be used:<ul>
   * <li><code>${LS_MPN_subscription_ID}</code>: the ID of the MPN subscription generating the push notification.
   * </ul>
   * The MpnBuilder object provides methods to build an appropriate JSON structure from its defining fields.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * named arguments are always mapped to its corresponding indexed argument, even if originally the notification format used a named argument.<BR>
   * Note: the content of this property may be subject to length restrictions (See the "General Concepts" document for more information).
   * 
   * **Lifecycle** This property can be changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>notification_format</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [format] the JSON structure to be used as the format of push notifications.
   * 
   * - See [FirebaseMpnBuilder]
   * - See [ApnsMpnBuilder]
   */
  Future<void> setNotificationFormat(String format) async {
    _notificationFormat = format;
    if (_remoteActive) {
      var arguments = <String, dynamic> {
        'notificationFormat': format
      };
      return await _invokeMethod('setNotificationFormat', arguments);
    }
  }
  /**
   * Checks if the MpnSubscription is currently "active" or not.
   * 
   * Most of the MpnSubscription properties cannot be modified if an MpnSubscription is "active".<BR>
   * The status of an MpnSubscription is changed to "active" through the [LightstreamerClient.subscribe] method and back to "inactive"
   * through the [LightstreamerClient.unsubscribe] and [LightstreamerClient.unsubscribeMpnSubscriptions] ones.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription is currently "active", false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  bool isActive() {
    return _status != 'UNKNOWN';
  }
  /**
   * Checks if the MpnSubscription is currently subscribed to through the server or not.
   * 
   * This flag is switched to true by server sent subscription events, and back to false in case of client disconnection,
   * [LightstreamerClient.unsubscribe] or [LightstreamerClient.unsubscribeMpnSubscriptions] calls, and server sent 
   * unsubscription events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription has been successfully subscribed on the server, false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  bool isSubscribed() {
    return _status == 'SUBSCRIBED' || _status == 'TRIGGERED';
  }
  /**
   * Checks if the MpnSubscription is currently triggered or not.
   * 
   * This flag is switched to true when a trigger expression has been set and it evaluated to true at least once. For this to happen, the subscription
   * must already be in "active" and "subscribed" states. It is switched back to false if the subscription is modified with a
   * [LightstreamerClient.subscribe] call on a copy of it, deleted with [LightstreamerClient.unsubscribe] or
   * [LightstreamerClient.unsubscribeMpnSubscriptions] calls, and server sent subscription events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription's trigger expression has been evaluated to true at least once, false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  bool isTriggered() {
    return _status == 'TRIGGERED';
  }
  /**
   * Inquiry method that gets the JSON structure used by the Sever to send notifications.
   *
   * **Returns** the JSON structure used by the Server to send notifications or null if the value is not available.
   *
   * - See [getNotificationFormat]
   */
  String? getActualNotificationFormat() {
    return _actualNotificationFormat;
  }
  /**
   * Inquiry method that gets the trigger expression evaluated by the Sever.
   *
   * **Returns** returns the trigger sent by the Server or null if the value is not available.
   *
   * - See [getTriggerExpression]
   */
  String? getActualTriggerExpression() {
    return _actualTrigger;
  }
  /**
   * The status of the subscription.
   * 
   * The status can be:<ul>
   * <li><code>UNKNOWN</code>: when the MPN subscription has just been created or deleted (i.e. unsubscribed). In this status [isActive], [isSubscribed] 
   * and [isTriggered] are all false.</li>
   * <li><code>ACTIVE</code>: when the MPN susbcription has been submitted to the server, but no confirm has been received yet. In this status [isActive] is true, 
   * [isSubscribed] and [isTriggered] are false.</li>
   * <li><code>SUBSCRIBED</code>: when the MPN subscription has been successfully subscribed on the server. If a trigger expression is set, it has not been
   * evaluated to true yet. In this status [isActive] and [isSubscribed] are true, [isTriggered] is false.</li>
   * <li><code>TRIGGERED</code>: when the MPN subscription has a trigger expression set, has been successfully subscribed on the server and
   * the trigger expression has been evaluated to true at least once. In this status [isActive], [isSubscribed] and [isTriggered] are all true.</li>
   * </ul>
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the status of the subscription.
   * 
   * - See [isActive]
   * - See [isSubscribed]
   * - See [isTriggered]
   */
  String getStatus() {
    return _status;
  }
  /**
   * The server-side timestamp of the subscription status.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>status_timestamp</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * **Returns** The server-side timestamp of the subscription status.
   * 
   * - See [getStatus]
   */
  int getStatusTimestamp() {
    return _statusTs;
  }
  /**
   * The server-side unique persistent ID of the MPN subscription.
   * 
   * The ID is available only after the MPN subscription has been successfully subscribed on the server. I.e. when its status is <code>SUBSCRIBED</code> or
   * <code>TRIGGERED</code>.<BR>
   * Note: more than one MpnSubscription may exists at any given time referring to the same MPN subscription, and thus with the same subscription ID.
   * For instance, copying an MpnSubscription with the copy initializer creates a second MpnSubscription instance with the same subscription ID. Also,
   * the <code>coalescing</code> flag of [LightstreamerClient.subscribe] may cause the assignment of a pre-existing MPN subscription ID 
   * to the new subscription.<BR>
   * Two MpnSubscription objects with the same subscription ID always represent the same server-side MPN subscription. It is the client's duty to keep the status
   * and properties of these objects up to date and aligned.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN subscription ID.
   */
  String? getSubscriptionId() {
    return _subscriptionId;
  }

  Future<T> _invokeMethod<T>(String method, [ Map<String, dynamic>? arguments ]) async {
    arguments = arguments ?? {};
    arguments["mpnSubId"] = _id;
    return await NativeBridge.instance.invokeMethod('MpnSubscription.$method', arguments);
  }
}