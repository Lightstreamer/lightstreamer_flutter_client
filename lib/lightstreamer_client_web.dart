/*
 * Copyright (C) 2022 Lightstreamer Srl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// **Lightstreamer Web Client SDK.**
@JS('lightstreamer')
library lightstreamer_client_web;

import 'package:js/js.dart';
import 'package:js/js_util.dart';

/**
 * Facade class for the management of the communication to
 * Lightstreamer Server. 
 * 
 * Used to provide configuration settings, event
 * handlers, operations for the control of the connection lifecycle,
 * [Subscription] handling and to send messages. <BR>
 * It also provides support for mobile push notifications (MPN) via
 * [MpnSubscription], a specific kind of subscription that
 * routes real-time updates via push notifications. <BR>
 * An instance of LightstreamerClient handles the communication with
 * Lightstreamer Server on a specified endpoint. Hence, it hosts one "Session";
 * or, more precisely, a sequence of Sessions, since any Session may fail
 * and be recovered, or it can be interrupted on purpose.
 * So, normally, a single instance of LightstreamerClient is needed. <BR>
 * However, multiple instances of LightstreamerClient can be used,
 * toward the same or multiple endpoints.
 * 
 * You can listen to the events generated by a session by registering an event listener, such as [ClientListener] or [SubscriptionListener]. 
 * These listeners allow you to handle various events, such as session creation, connection status, subscription updates, and server messages. 
 * However, you should be aware that the event notifications are dispatched by a single thread, the so-called event thread. 
 * This means that if the operations of a listener are slow or blocking, they will delay the processing of the other listeners and 
 * affect the performance of your application. 
 * Therefore, you should delegate any slow or blocking operations to a dedicated thread, and keep the listener methods as fast and simple as possible.
 * Note that even if you create multiple instances of LightstreamerClient, they will all use a single event thread, that is shared among them.
 */
@JS()
@staticInterop
class LightstreamerClient {
  /**
   * Static method that permits to configure the logging system used by the library. 
   * 
   * The logging system must respect the [LoggerProvider] 
   * interface. A custom class can be used to wrap any third-party 
   * logging system. <BR>
   * If no logging system is specified, all the generated log is discarded. <BR>
   * The following categories are available to be consumed:
   * <ul>
   *  <li>lightstreamer.stream:<BR>
   *  logs socket activity on Lightstreamer Server connections;<BR>
   *  at INFO level, socket operations are logged;<BR>
   *  at DEBUG level, read/write data exchange is logged.
   *  </li>
   *  <li>lightstreamer.protocol:<BR>
   *  logs requests to Lightstreamer Server and Server answers;<BR>
   *  at INFO level, requests are logged;<BR>
   *  at DEBUG level, request details and events from the Server are logged.
   *  <li>lightstreamer.session:<BR>
   *  logs Server Session lifecycle events;<BR>
   *  at INFO level, lifecycle events are logged;<BR>
   *  at DEBUG level, lifecycle event details are logged.
   *  </li>
   *  <li>lightstreamer.subscriptions:<BR>
   *  logs subscription requests received by the clients and the related updates;<BR>
   *  at WARN level, alert events from the Server are logged;<BR>
   *  at INFO level, subscriptions and unsubscriptions are logged;<BR>
   *  at DEBUG level, requests batching and update details are logged.
   *  </li>
   *  <li>lightstreamer.actions:<BR>
   *  logs settings / API calls.
   *  </li>
   * </ul>
   *
   * - [provider] A [LoggerProvider] instance that will be used to generate log messages by the library classes.
   */
  external static void setLoggerProvider(LoggerProvider provider);
  /**
   * Creates an object to be configured to connect to a Lightstreamer server
   * and to handle all the communications with it.
   * 
   * Each LightstreamerClient is the entry point to connect to a Lightstreamer server, 
   * subscribe to as many items as needed and to send messages. 
   * 
   * - [serverAddress] the address of the Lightstreamer Server to
   * which this LightstreamerClient will connect to. It is possible to specify it later
   * by using null here. See [ConnectionDetails.setServerAddress] 
   * for details.
   * - [adapterSet] the name of the Adapter Set mounted on Lightstreamer Server 
   * to be used to handle all requests in the Session associated with this 
   * LightstreamerClient. It is possible not to specify it at all or to specify 
   * it later by using null here. See [ConnectionDetails.setAdapterSet] 
   * for details.
   *
   * **Throws** IllegalArgumentException if a not valid address is passed. See
   * [ConnectionDetails.setServerAddress] for details.
   */
  external factory LightstreamerClient(String serverAddress, String adapterSet);
}

extension LightstreamerClientExt on LightstreamerClient {
  /**
   * Data object that contains the details needed to open a connection to 
   * a Lightstreamer Server. 
   * 
   * This instance is set up by the LightstreamerClient object at 
   * its own creation. <BR>
   * Properties of this object can be overwritten by values received from a 
   * Lightstreamer Server. 
   */
  external ConnectionDetails get connectionDetails;
  /**
   * Data object that contains options and policies for the connection to 
   * the server. 
   * 
   * This instance is set up by the LightstreamerClient object at 
   * its own creation. <BR>
   * Properties of this object can be overwritten by values received from a 
   * Lightstreamer Server. 
   */
  external ConnectionOptions get connectionOptions;
  /**
   * Operation method that requests to open a Session against the configured Lightstreamer Server.
   * 
   * When connect() is called, unless a single transport was forced through 
   * [ConnectionOptions.setForcedTransport], the so called "Stream-Sense" mechanism is started: 
   * if the client does not receive any answer for some seconds from the streaming connection, then it 
   * will automatically open a polling connection. <BR>
   * A polling connection may also be opened if the environment is not suitable for a streaming connection. <BR>
   * Note that as "polling connection" we mean a loop of polling requests, each of which requires opening a 
   * synchronous (i.e. not streaming) connection to Lightstreamer Server.
   * 
   * **Lifecycle** Note that the request to connect is accomplished by the client in a separate thread; this means 
   * that an invocation to [getStatus] right after connect() might not reflect the change yet. <BR> 
   * When the request to connect is finally being executed, if the current status
   * of the client is not DISCONNECTED, then nothing will be done.
   * 
   * **Throws** IllegalStateException if no server address was configured.
   * 
   * - See [getStatus]
   * - See [disconnect]
   * - See [ClientListener.onStatusChange]
   * - See [ConnectionDetails.setServerAddress]
   */
  external void connect();
  /**
   * Operation method that requests to close the Session opened against the configured Lightstreamer Server (if any).
   * 
   * When disconnect() is called, the "Stream-Sense" mechanism is stopped. <BR>
   * Note that active Subscription instances, associated with this LightstreamerClient instance, are preserved 
   * to be re-subscribed to on future Sessions.
   * 
   * **Lifecycle**  Note that the request to disconnect is accomplished by the client in a separate thread; this 
   * means that an invocation to [getStatus] right after disconnect() might not reflect the change yet. <BR> 
   * When the request to disconnect is finally being executed, if the status of the client is "DISCONNECTED", 
   * then nothing will be done.
   * 
   * - See [connect]
   */
  external void disconnect();
  /**
   * Inquiry method that gets the current client status and transport (when applicable).
   * 
   * **Returns** The current client status. It can be one of the following values:
   * <ul>
   *  <li>"CONNECTING" the client is waiting for a Server's response in order to establish a connection;</li>
   *  <li>"CONNECTED:STREAM-SENSING" the client has received a preliminary response from the server and 
   *  is currently verifying if a streaming connection is possible;</li>
   *  <li>"CONNECTED:WS-STREAMING" a streaming connection over WebSocket is active;</li>
   *  <li>"CONNECTED:HTTP-STREAMING" a streaming connection over HTTP is active;</li>
   *  <li>"CONNECTED:WS-POLLING" a polling connection over WebSocket is in progress;</li>
   *  <li>"CONNECTED:HTTP-POLLING" a polling connection over HTTP is in progress;</li>
   *  <li>"STALLED" the Server has not been sending data on an active streaming connection for longer 
   *  than a configured time;</li>
   *  <li>"DISCONNECTED:WILL-RETRY" no connection is currently active but one will be opened (possibly after a timeout);</li>
   *  <li>"DISCONNECTED:TRYING-RECOVERY" no connection is currently active,
   *  but one will be opened as soon as possible, as an attempt to recover
   *  the current session after a connection issue;</li> 
   *  <li>"DISCONNECTED" no connection is currently active.</li>
   * </ul>
   * 
   * - See [ClientListener.onStatusChange]
   */
  external String getStatus();
  @JS('addListener') external void _addListener(_ClientListener listener);
  @JS('removeListener') external void _removeListener(_ClientListener listener);
  @JS('getListeners') external List<dynamic> _getListeners();
  @JS('sendMessage') external void _sendMessage(String msg, [String? sequence, int? delayTimeout, _ClientMessageListener? listener, bool? enqueueWhileDisconnected]);
  /**
   * Operation method that adds a Subscription to the list of "active" Subscriptions. The Subscription cannot already be in the "active" state.
   * 
   * Active subscriptions are subscribed to through the server as soon as possible (i.e. as soon as there is a 
   * session available). Active Subscription are automatically persisted across different sessions as long as a 
   * related unsubscribe call is not issued.
   * 
   * **Lifecycle** Subscriptions can be given to the LightstreamerClient at any time. Once done the Subscription 
   * immediately enters the "active" state. <BR>
   * Once "active", a Subscription instance cannot be provided again to a LightstreamerClient unless it is 
   * first removed from the "active" state through a call to [unsubscribe]. <BR>
   * Also note that forwarding of the subscription to the server is made in a separate thread. <BR>
   * A successful subscription to the server will be notified through a [SubscriptionListener.onSubscription]
   * event.
   * 
   * - [sub] A Subscription object, carrying all the information needed to process real-time values.
   * 
   * - See [unsubscribe]
   */
  external void subscribe(Subscription sub);
  /**
   * Operation method that removes a Subscription that is currently in the "active" state.
   *  
   * By bringing back a Subscription to the "inactive" state, the unsubscription from all its items is 
   * requested to Lightstreamer Server.
   * 
   * **Lifecycle** Subscription can be unsubscribed from at any time. Once done the Subscription immediately 
   * exits the "active" state. <BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread. <BR>
   * The unsubscription will be notified through a [SubscriptionListener.onUnsubscription] event.
   * 
   * - [sub] An "active" Subscription object that was activated by this LightstreamerClient 
   * instance.
   */
  external void unsubscribe(Subscription sub);
  @JS('getSubscriptions') external List<dynamic> _getSubscriptions();

  /**
   * Adds a listener that will receive events from the LightstreamerClient instance.
   *  
   * The same listener can be added to several different LightstreamerClient instances.
   *
   * **Lifecycle** A listener can be added at any time. A call to add a listener already 
   * present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the 
   * ClientListener interface.
   * 
   * - See [removeListener]
   */
  void addListener(ClientListener listener) {
    _addListener(listener._asJSObject);
  }
  /**
   * Removes a listener from the LightstreamerClient instance so that it will not receive events anymore.
   * 
   * **Lifecycle** a listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(ClientListener listener) {
    _removeListener(listener._asJSObject);
  }
  /**
   * Returns a list containing the [ClientListener] instances that were added to this client.
   *
   * **Returns** a list containing the listeners that were added to this client. 
   * - See [addListener]
   */
  List<ClientListener> getListeners() {
    return _getListeners().map((obj) => (obj as _ClientListener)._asDartObject).toList();
  }
  /**
   * Operation method that sends a message to the Server. 
   * 
   * The message is interpreted and handled by 
   * the Metadata Adapter associated to the current Session. This operation supports in-order 
   * guaranteed message delivery with automatic batching. In other words, messages are guaranteed 
   * to arrive exactly once and respecting the original order, whatever is the underlying transport 
   * (HTTP or WebSockets). Furthermore, high frequency messages are automatically batched, if necessary,
   * to reduce network round trips. <BR>
   * Upon subsequent calls to the method, the sequential management of the involved messages is guaranteed. 
   * The ordering is determined by the order in which the calls to sendMessage are issued. <BR>
   * If a message, for any reason, doesn't reach the Server (this is possible with the HTTP transport),
   * it will be resent; however, this may cause the subsequent messages to be delayed.
   * For this reason, each message can specify a "delayTimeout", which is the longest time the message, after
   * reaching the Server, can be kept waiting if one of more preceding messages haven't been received yet.
   * If the "delayTimeout" expires, these preceding messages will be discarded; any discarded message
   * will be notified to the listener through [ClientMessageListener.onDiscarded].
   * Note that, because of the parallel transport of the messages, if a zero or very low timeout is 
   * set for a message and the previous message was sent immediately before, it is possible that the
   * latter gets discarded even if no communication issues occur.
   * The Server may also enforce its own timeout on missing messages, to prevent keeping the subsequent
   * messages for long time. <BR>
   * Sequence identifiers can also be associated with the messages. In this case, the sequential management is 
   * restricted to all subsets of messages with the same sequence identifier associated. <BR>
   * Notifications of the operation outcome can be received by supplying a suitable listener. The supplied 
   * listener is guaranteed to be eventually invoked; listeners associated with a sequence are guaranteed 
   * to be invoked sequentially. <BR>
   * The "UNORDERED_MESSAGES" sequence name has a special meaning. For such a sequence, immediate processing 
   * is guaranteed, while strict ordering and even sequentialization of the processing is not enforced. 
   * Likewise, strict ordering of the notifications is not enforced. However, messages that, for any reason, 
   * should fail to reach the Server whereas subsequent messages had succeeded, might still be discarded after 
   * a server-side timeout, in order to ensure that the listener eventually gets a notification.<BR>
   * Moreover, if "UNORDERED_MESSAGES" is used and no listener is supplied, a "fire and forget" scenario
   * is assumed. In this case, no checks on missing, duplicated or overtaken messages are performed at all,
   * so as to optimize the processing and allow the highest possible throughput.
   * 
   * **Lifecycle** Since a message is handled by the Metadata Adapter associated to the current connection, a
   * message can be sent only if a connection is currently active. If the special enqueueWhileDisconnected 
   * flag is specified it is possible to call the method at any time and the client will take care of sending
   * the message as soon as a connection is available, otherwise, if the current status is "DISCONNECTED*", 
   * the message will be abandoned and the [ClientMessageListener.onAbort] event will be fired. <BR>
   * Note that, in any case, as soon as the status switches again to "DISCONNECTED*", any message still pending 
   * is aborted, including messages that were queued with the enqueueWhileDisconnected flag set to true. <BR>
   * Also note that forwarding of the message to the server is made in a separate thread, hence, if a message 
   * is sent while the connection is active, it could be aborted because of a subsequent disconnection. 
   * In the same way a message sent while the connection is not active might be sent because of a subsequent
   * connection.
   * 
   * - [message] a text message, whose interpretation is entirely demanded to the Metadata Adapter
   * associated to the current connection.
   * - [sequence] an alphanumeric identifier, used to identify a subset of messages to be managed in sequence; 
   * underscore characters are also allowed. If the "UNORDERED_MESSAGES" identifier is supplied, the message will 
   * be processed in the special way described above. The parameter is optional; if set to null, "UNORDERED_MESSAGES" 
   * is used as the sequence name. 
   * - [delayTimeout] a timeout, expressed in milliseconds. If higher than the Server configured timeout
   * on missing messages, the latter will be used instead. <BR> 
   * The parameter is optional; if a negative value is supplied, the Server configured timeout on missing
   * messages will be applied. <BR>
   * This timeout is ignored for the special "UNORDERED_MESSAGES" sequence, although a server-side timeout
   * on missing messages still applies.
   * - [listener] an object suitable for receiving notifications about the processing outcome. The parameter is 
   * optional; if not supplied, no notification will be available.
   * - [enqueueWhileDisconnected] if this flag is set to true, and the client is in a disconnected status when
   * the provided message is handled, then the message is not aborted right away but is queued waiting for a new
   * session. Note that the message can still be aborted later when a new session is established.
   */
  void sendMessage(String message, [String? sequence, int? delayTimeout, ClientMessageListener? listener, bool? enqueueWhileDisconnected]) {
    _sendMessage(message, sequence, delayTimeout, listener?._asJSObject, enqueueWhileDisconnected);
  }
  /**
   * Inquiry method that returns a list containing all the Subscription instances that are 
   * currently "active" on this LightstreamerClient.
   * 
   * Internal second-level Subscription are not included.
   *
   * **Returns** A list, containing all the Subscription currently "active" on this LightstreamerClient. <BR>
   * The list can be empty.
   * - See [subscribe]
   */
  List<Subscription> getSubscriptions() {
    return _getSubscriptions().cast<Subscription>();
  }

  /**
   * Operation method that registers the MPN device on the server's MPN Module.
   * 
   * By registering an MPN device, the client enables MPN functionalities such as [subscribe].
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An [MpnDevice] can be registered at any time. The registration will be notified through a [MpnDeviceListener.onRegistered] event.
   * Note that forwarding of the registration to the server is made in a separate thread.
   * 
   * - [device] An [MpnDevice] instance, carrying all the information about the MPN device.
   * 
   * **Throws** IllegalArgumentException if the specified device is null.
   * 
   * - See [subscribe]
   */
  external void registerForMpn(MpnDevice device);
  /**
   * Operation method that subscribes an MpnSubscription on server's MPN Module.
   * 
   * This operation adds the [MpnSubscription] to the list of "active" subscriptions. MPN subscriptions are activated on the server as soon as possible
   * (i.e. as soon as there is a session available and subsequently as soon as the MPN device registration succeeds). Differently than real-time subscriptions,
   * MPN subscriptions are persisted on the server's MPN Module database and survive the session they were created on.<BR>
   * If the <code>coalescing</code> flag is <i>set</i>, the activation of two MPN subscriptions with the same Adapter Set, Data Adapter, Group, Schema and trigger expression will be
   * considered the same MPN subscription. Activating two such subscriptions will result in the second activation modifying the first MpnSubscription (that
   * could have been issued within a previous session). If the <code>coalescing</code> flag is <i>not set</i>, two activations are always considered different MPN subscriptions,
   * whatever the Adapter Set, Data Adapter, Group, Schema and trigger expression are set.<BR>
   * The rationale behind the <code>coalescing</code> flag is to allow simple apps to always activate their MPN subscriptions when the app starts, without worrying if
   * the same subscriptions have been activated before or not. In fact, since MPN subscriptions are persistent, if they are activated every time the app starts and
   * the <code>coalescing</code> flag is not set, every activation is a <i>new</i> MPN subscription, leading to multiple push notifications for the same event.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An MpnSubscription can be given to the LightstreamerClient once an MpnDevice registration has been requested. The MpnSubscription
   * immediately enters the "active" state.<BR>
   * Once "active", an MpnSubscription instance cannot be provided again to an LightstreamerClient unless it is first removed from the "active" state through
   * a call to [unsubscribe].<BR>
   * Note that forwarding of the subscription to the server is made in a separate thread.<BR>
   * A successful subscription to the server will be notified through an [MpnSubscriptionListener.onSubscription] event.
   * 
   * - [sub] An MpnSubscription object, carrying all the information to route real-time data via push notifications.
   * - [coalescing] A flag that specifies if the MPN subscription must coalesce with any pre-existing MPN subscription with the same Adapter Set, Data Adapter,
   * Group, Schema and trigger expression.
   * 
   * **Throws** IllegalStateException if the given MPN subscription does not contain a field list/field schema.
   * 
   * **Throws** IllegalStateException if the given MPN subscription does not contain a item list/item group.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * **Throws** IllegalStateException if the given MPN subscription is already active.
   * 
   * - See [unsubscribe]
   * - See [unsubscribeMpnSubscriptions]
   */
  external void subscribeMpn(MpnSubscription subscription, bool coalescing);
  /**
   * Operation method that unsubscribes an MpnSubscription from the server's MPN Module.
   * 
   * This operation removes the MpnSubscription from the list of "active" subscriptions.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** An MpnSubscription can be unsubscribed from at any time. Once done the MpnSubscription immediately exits the "active" state.<BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread.<BR>
   * The unsubscription will be notified through an [MpnSubscriptionListener.onUnsubscription] event.
   * 
   * - [sub] An "active" MpnSubscription object.
   * 
   * **Throws** IllegalStateException if the given MPN subscription is not active.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [subscribe]
   * - See [unsubscribeMpnSubscriptions]
   */
  external void unsubscribeMpn(MpnSubscription sub);
  /**
   * Operation method that unsubscribes all the MPN subscriptions with a specified status from the server's MPN Module.
   * 
   * By specifying a status filter it is possible to unsubscribe multiple MPN subscriptions at once. E.g. by passing <code>TRIGGERED</code> it is possible
   * to unsubscribe all triggered MPN subscriptions. This operation removes the involved MPN subscriptions from the list of "active" subscriptions.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** Multiple unsubscription can be requested at any time. Once done the involved MPN subscriptions immediately exit the "active" state.<BR>
   * Note that forwarding of the unsubscription to the server is made in a separate thread.<BR>
   * The unsubscription will be notified through an [MpnSubscriptionListener.onUnsubscription] event to all involved MPN subscriptions.
   * 
   * - [filter] A status name to be used to select the MPN subscriptions to unsubscribe. If null all existing MPN subscriptions
   * are unsubscribed. Possible filter values are:<ul>
   * <li><code>ALL</code> or null</li>
   * <li><code>TRIGGERED</code></li>
   * <li><code>SUBSCRIBED</code></li>
   * </ul>
   * 
   * **Throws** IllegalArgumentException if the given filter is not valid.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [subscribe]
   * - See [unsubscribe]
   */
  external void unsubscribeMpnSubscriptions(String? filter);
  /**
   * Inquiry method that returns the MpnSubscription with the specified subscription ID, or null if not found.
   * 
   * The object returned by this method can be an object created by the user, via MpnSubscription constructors, or an object created by the client,
   * to represent pre-existing MPN subscriptions.<BR>
   * Note that objects returned by this method may be substitutued at any time with equivalent ones: do not rely on pointer matching, instead rely on the
   * [MpnSubscription.getSubscriptionId] value to verify the equivalence of two MpnSubscription objects. Substitutions may happen
   * when an MPN subscription is modified, or when it is coalesced with a pre-existing subscription.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * - [subscriptionId] The subscription ID to search for.
   * 
   * **Returns** the MpnSubscription with the specified ID, or null if not found.
   * 
   * **Throws** IllegalArgumentException if the given subscription ID is null.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [getMpnSubscriptions]
   */
  @JS('getMpnSubscriptions') external List<dynamic> _getMpnSubscriptions(String? filter);
  external MpnSubscription? findMpnSubscription(String subscriptionId);

  /**
   * Inquiry method that returns a collection of the existing MPN subscription with a specified status.
   * 
   * Can return both objects created by the user, via [MpnSubscription] constructors, and objects created by the client, to represent pre-existing MPN subscriptions.<BR>
   * Note that objects in the collection may be substituted at any time with equivalent ones: do not rely on pointer matching, instead rely on the
   * [MpnSubscription.getSubscriptionId] value to verify the equivalence of two MpnSubscription objects. Substitutions may happen
   * when an MPN subscription is modified, or when it is coalesced with a pre-existing subscription.
   * 
   * **General Edition Note** MPN is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** The collection is available once an MpnDevice registration has been requested, but reflects the actual server's collection only
   * after an [MpnDeviceListener.onSubscriptionsUpdated] event has been notified.
   * 
   * - [filter] An MPN subscription status name to be used to select the MPN subscriptions to return. If null all existing MPN subscriptions
   * are returned. Possible filter values are:<ul>
   * <li><code>ALL</code> or null</li>
   * <li><code>TRIGGERED</code></li>
   * <li><code>SUBSCRIBED</code></li>
   * </ul>
   * 
   * **Returns** the collection of [MpnSubscription] with the specified status.
   * 
   * **Throws** IllegalArgumentException if the given filter is not valid.
   * 
   * **Throws** IllegalStateException if there is no MPN device registered.
   * 
   * - See [findMpnSubscription]
   */
  List<MpnSubscription> getMpnSubscriptions(String? filter) {
    return _getMpnSubscriptions(filter).cast<MpnSubscription>();
  }
}

@JS()
@staticInterop
class _ClientListener {}

extension _ClientListenerExt on _ClientListener {
  external ClientListener get _asDartObject;
}

/**
 * Interface to be implemented to listen to [LightstreamerClient] events comprehending notifications of 
 * connection activity and errors.
 * 
 * Events for these listeners are dispatched by a different thread than the one that generates them. 
 * This means that, upon reception of an event, it is possible that the internal state of the client has changed.
 * On the other hand, all the notifications for a single LightstreamerClient, including notifications to
 * [ClientListener]s, [SubscriptionListener]s and [ClientMessageListener]s will be dispatched by the 
 * same thread.
 */
@JSExport()
abstract class ClientListener {
  /**
   * Event handler that receives a notification each time the LightstreamerClient status has changed. 
   * 
   * The status changes 
   * may be originated either by custom actions (e.g. by calling [LightstreamerClient.disconnect]) or by internal 
   * actions.
   * The normal cases are the following:
   * <ul>
   *   <li>After issuing connect() when the current status is "DISCONNECTED*", the client will switch to "CONNECTING" 
   *       first and to "CONNECTED:STREAM-SENSING" as soon as the pre-flight request receives its answer.<BR> 
   *       As soon as the new session is established, it will switch to "CONNECTED:WS-STREAMING" if the environment 
   *       permits WebSockets; otherwise it will switch to "CONNECTED:HTTP-STREAMING" if the environment permits streaming 
   *       or to "CONNECTED:HTTP-POLLING" as a last resort.</li>
   *   <li>On the other hand, after issuing connect when the status is already "CONNECTED:*" a switch to "CONNECTING"
   *       is usually not needed and the current session is kept.</li>
   *   <li>After issuing [LightstreamerClient.disconnect], the status will switch to "DISCONNECTED".</li>
   *   <li>In case of a server connection refusal, the status may switch from "CONNECTING" directly to "DISCONNECTED". 
   *       After that, the [onServerError] event handler will be invoked.</li>
   * </ul>
   * Possible special cases are the following:
   * <ul>
   *   <li>In case of Server unavailability during streaming, the status may switch from "CONNECTED:*-STREAMING" 
   *       to "STALLED" (see [ConnectionOptions.setStalledTimeout]). If the unavailability ceases, the status 
   *       will switch back to "CONNECTED:*-STREAMING"; otherwise, if the unavailability persists 
   *       (see [ConnectionOptions.setReconnectTimeout]), the status will switch to "DISCONNECTED:TRYING-RECOVERY"
   *       and eventually to "CONNECTED:*-STREAMING".</li>
   *   <li>In case the connection or the whole session is forcibly closed by the Server, the status may switch 
   *       from "CONNECTED:*-STREAMING" or "CONNECTED:*-POLLING" directly to "DISCONNECTED". After that, 
   *       the [onServerError] event handler will be invoked.</li>
   *   <li>Depending on the setting in [ConnectionOptions.setSlowingEnabled], in case of slow update processing, 
   *       the status may switch from "CONNECTED:WS-STREAMING" to "CONNECTED:WS-POLLING" or from "CONNECTED:HTTP-STREAMING" 
   *       to "CONNECTED:HTTP-POLLING".</li>
   *   <li>If the status is "CONNECTED:*-POLLING" and any problem during an intermediate poll occurs, the status may 
   *       switch to "CONNECTING" and eventually to "CONNECTED:*-POLLING". The same may hold for the "CONNECTED:*-STREAMING" case, 
   *       when a rebind is needed.</li>
   *   <li>In case a forced transport was set through [ConnectionOptions.setForcedTransport], only the 
   *       related final status or statuses are possible.</li>
   *   <li>In case of connection problems, the status may switch from any value
   *       to "DISCONNECTED:WILL-RETRY" (see [ConnectionOptions.setRetryDelay]),
   *       then to "CONNECTING" and a new attempt will start.
   *       However, in most cases, the client will try to recover the current session;
   *       hence, the "DISCONNECTED:TRYING-RECOVERY" status will be entered and the recovery attempt will start.</li>
   *   <li>In case of connection problems during a recovery attempt, the status may stay
   *       in "DISCONNECTED:TRYING-RECOVERY" for long time, while further attempts are made.
   *       If the recovery is no longer possible, the current session will be abandoned
   *       and the status will switch to "DISCONNECTED:WILL-RETRY" before the next attempts.</li>
   * </ul>
   * By setting a custom handler it is possible to perform actions related to connection and disconnection occurrences. 
   * Note that [LightstreamerClient.connect] and [LightstreamerClient.disconnect], as any other method, can 
   * be issued directly from within a handler.
   * 
   * - [status] The new status. It can be one of the following values:
   * <ul>
   *   <li>"CONNECTING" the client has started a connection attempt and is waiting for a Server answer.</li>
   *   <li>"CONNECTED:STREAM-SENSING" the client received a first response from the server and is now evaluating if 
   *   a streaming connection is fully functional.</li>
   *   <li>"CONNECTED:WS-STREAMING" a streaming connection over WebSocket has been established.</li>
   *   <li>"CONNECTED:HTTP-STREAMING" a streaming connection over HTTP has been established.</li>
   *   <li>"CONNECTED:WS-POLLING" a polling connection over WebSocket has been started. Note that, unlike polling over 
   *   HTTP, in this case only one connection is actually opened (see [ConnectionOptions.setSlowingEnabled]).</li>
   *   <li>"CONNECTED:HTTP-POLLING" a polling connection over HTTP has been started.</li>
   *   <li>"STALLED" a streaming session has been silent for a while, the status will eventually return to its previous 
   *   CONNECTED:*-STREAMING status or will switch to "DISCONNECTED:WILL-RETRY" / "DISCONNECTED:TRYING-RECOVERY".</li>
   *   <li>"DISCONNECTED:WILL-RETRY" a connection or connection attempt has been closed; a new attempt will be 
   *   performed (possibly after a timeout).</li>
   *   <li>"DISCONNECTED:TRYING-RECOVERY" a connection has been closed and
   *   the client has started a connection attempt and is waiting for a Server answer;
   *   if successful, the underlying session will be kept.</li>
   *   <li>"DISCONNECTED" a connection or connection attempt has been closed. The client will not connect anymore until 
   *   a new [LightstreamerClient.connect] call is issued.</li>
   * </ul>
   *   
   * - See [LightstreamerClient.connect]
   * - See [LightstreamerClient.disconnect]
   * - See [LightstreamerClient.getStatus]
   */
  void onStatusChange(String status) {}
  /**
   * Event handler that receives a notification when the ClientListener instance is removed from a LightstreamerClient 
   * through [LightstreamerClient.removeListener]. 
   * 
   * This is the last event to be fired on the listener.
   */
  void onListenEnd(void dummy) {}
  /**
   * Event handler that receives a notification when the ClientListener instance is added to a LightstreamerClient 
   * through [LightstreamerClient.addListener]. 
   * 
   * This is the first event to be fired on the listener.
   */
  void onListenStart(void dummy) {}
  /**
   * Event handler that receives a notification each time  the value of a property of 
   * [LightstreamerClient.connectionDetails] or [LightstreamerClient.connectionOptions] 
   * is changed.
   * 
   * Properties of these objects can be modified by direct calls to them or
   * by server sent events.
   * 
   * - [property] the name of the changed property.
   * <BR>Possible values are:
   * <ul>
   * <li>adapterSet</li>
   * <li>serverAddress</li>
   * <li>user</li>
   * <li>password</li>
   * <li>contentLength</li>
   * <li>requestedMaxBandwidth</li>
   * <li>reverseHeartbeatInterval</li>
   * <li>httpExtraHeaders</li>
   * <li>httpExtraHeadersOnSessionCreationOnly</li>
   * <li>forcedTransport</li>
   * <li>retryDelay</li>
   * <li>firstRetryMaxDelay</li>
   * <li>sessionRecoveryTimeout</li>
   * <li>stalledTimeout</li>
   * <li>reconnectTimeout</li>
   * <li>slowingEnabled</li>
   * <li>serverInstanceAddressIgnored</li>
   * <li>cookieHandlingRequired</li>
   * <li>proxy</li>
   * <li>serverInstanceAddress</li>
   * <li>serverSocketName</li>
   * <li>clientIp</li>
   * <li>sessionId</li>
   * <li>realMaxBandwidth</li>
   * <li>idleTimeout</li>
   * <li>keepaliveInterval</li>
   * <li>pollingInterval</li>
   * </ul>
   * 
   * - See [LightstreamerClient.connectionDetails]
   * - See [LightstreamerClient.connectionOptions]
   */
  void onPropertyChange(String property) {}
  /**
   * Event handler that is called when the Server notifies a refusal on the client attempt to open
   * a new connection or the interruption of a streaming connection.
   * 
   * In both cases, the [onStatusChange] event handler has already been invoked
   * with a "DISCONNECTED" status and no recovery attempt has been performed.
   * By setting a custom handler, however, it is possible to override this and perform custom recovery actions.
   * 
   * - [errorCode] The error code. It can be one of the following:
   * <ul>
   *   <li>1 - user/password check failed</li>
   *   <li>2 - requested Adapter Set not available</li>
   *   <li>7 - licensed maximum number of sessions reached (this can only happen with some licenses)</li>
   *   <li>8 - configured maximum number of sessions reached</li>
   *   <li>9 - configured maximum server load reached</li>
   *   <li>10 - new sessions temporarily blocked</li>
   *   <li>11 - streaming is not available because of Server license restrictions (this can only happen with special licenses).</li>
   *   <li>21 - a request for this session has unexpectedly reached a wrong Server instance, which suggests that a routing issue may be in place.</li>
   *   <li>30-41 - the current connection or the whole session has been closed by external agents; the possible cause may be:
   *     <ul>
   *       <li>The session was closed on the Server side (via software or by the administrator) (32),
   *           or through a client "destroy" request (31);</li>
   *       <li>The Metadata Adapter imposes limits on the overall open sessions for the current user and has requested 
   *           the closure of the current session upon opening of a new session for the same user on a different browser 
   *           window (35);</li>
   *       <li>An unexpected error occurred on the Server while the session was in activity (33, 34);</li>
   *       <li>An unknown or unexpected cause; any code different from the ones identified in the above cases could be 
   *           issued. A detailed description for the specific cause is currently not supplied (i.e. errorMessage is 
   *           null in this case).</li>
   *   </ul>
   *   <li>60 - this version of the client is not allowed by the current license terms.</li>
   *   <li>61 - there was an error in the parsing of the server response thus the client cannot continue with the current session.</li>
   *   <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection.</li>
   *   <li>68 - the Server could not open or continue with the session because of an internal error.</li>
   *   <li>70 - an unusable port was configured on the server address.</li>
   *   <li>71 - this kind of client is not allowed by the current license terms.</li>
   *   <li>&lt;= 0 - the Metadata Adapter has refused the user connection; the code value is dependent on the specific 
   *       Metadata Adapter implementation</li>
   * </ul>
   * 
   * - [errorMessage] The description of the error as sent by the Server.
   * 
   * - See [onStatusChange]
   * - See [ConnectionDetails.setAdapterSet]
   */
  void onServerError(int errorCode, String errorMessage) {}
  /**
   * Notifies that the Server has sent a keepalive message because a streaming connection
   * is in place and no update had been sent for the configured time
   * (see [ConnectionOptions.setKeepaliveInterval]).
   * 
   * However, note that the lack of both updates and keepalives is already managed by the library
   * (see [ConnectionOptions.setReconnectTimeout] and [ConnectionOptions.setStalledTimeout]).
   */
  void onServerKeepalive() {}

  late final _ClientListener _that;
  ClientListener() {
    _that = createDartExport(this) as _ClientListener;
  }
  _ClientListener get _asJSObject => _that;
  ClientListener get _asDartObject => this;
}

@JS()
@staticInterop
class _ClientMessageListener {}

extension _ClientMessageListenerExt on _ClientMessageListener {
  external ClientMessageListener get _asDartObject;
}

/**
 * Interface to be implemented to listen to [LightstreamerClient.sendMessage] events reporting a message processing outcome. 
 * 
 * Events for these listeners are dispatched by a different thread than the one that generates them.
 * All the notifications for a single LightstreamerClient, including notifications to
 * [ClientListener]s, [SubscriptionListener]s and [ClientMessageListener]s will be dispatched by the 
 * same thread.
 * Only one event per message is fired on this listener.
 */
@JSExport()
abstract class ClientMessageListener {
  /**
   * Event handler that is called by Lightstreamer when any notifications of the processing outcome of the related 
   * message haven't been received yet and can no longer be received. 
   * 
   * Typically, this happens after the session 
   * has been closed. In this case, the client has no way of knowing the processing outcome and any outcome is possible.
   * - [originalMessage] the message to which this notification is related.
   * - [sentOnNetwork] true if the message was sent on the network, false otherwise. 
   *        Even if the flag is true, it is not possible to infer whether the message actually reached the 
   *        Lightstreamer Server or not.
   */
  void onAbort(String originalMessage, bool sentOnNetwork) {}
  /**
   * Event handler that is called by Lightstreamer when the related message has been processed by the Server but the 
   * expected processing outcome could not be achieved for any reason.
   * 
   * - [originalMessage] the message to which this notification is related.
   * - [errorCode] the error code sent by the Server. It can be one of the following:
   *        <ul><li>&lt;= 0 - the Metadata Adapter has refused the message; the code value is dependent on the 
   *        specific Metadata Adapter implementation.</li></ul>
   * - [errorMessage] the description of the error sent by the Server.
   */
  void onDeny(String originalMessage, int errorCode, String errorMessage) {}
  /**
   * Event handler that is called by Lightstreamer to notify that the related message has been discarded by the Server.
   * 
   * This means that the message has not reached the Metadata Adapter and the message next in the sequence is considered 
   * enabled for processing.
   * - [originalMessage] the message to which this notification is related.
   */
  void onDiscarded(String originalMessage) {}
  /**
   * Event handler that is called by Lightstreamer when the related message has been processed by the Server but the 
   * processing has failed for any reason. 
   * 
   * The level of completion of the processing by the Metadata Adapter cannot be 
   * determined.
   * - [originalMessage] the message to which this notification is related.
   */
  void onError(String originalMessage) {}
  /**
   * Event handler that is called by Lightstreamer when the related message has been processed by the Server with success.
   * 
   * - [originalMessage] the message to which this notification is related.
   * - [response] the response from the Metadata Adapter. If not supplied (i.e. supplied as null), an empty message is received here.
   */
  void onProcessed(String originalMessage, String response) {}

  late final _ClientMessageListener _that;
  ClientMessageListener() {
    _that = createDartExport(this) as _ClientMessageListener;
  }
  _ClientMessageListener get _asJSObject => _that;
  ClientMessageListener get _asDartObject => this;
}

@JS()
@staticInterop
class _SubscriptionListener {}

extension _SubscriptionListenerExt on _SubscriptionListener {
  external SubscriptionListener get _asDartObject;
}

/**
 * Interface to be implemented to listen to [Subscription] events comprehending notifications of subscription/unsubscription, 
 * updates, errors and others.
 * 
 * Events for these listeners are dispatched by a different thread than the one that generates them. 
 * This means that, upon reception of an event, it is possible that the internal state of the client has changed.
 * On the other hand, all the notifications for a single LightstreamerClient, including notifications to
 * [ClientListener]s, [SubscriptionListener]s and [ClientMessageListener]s will be dispatched by the 
 * same thread.
 */
@JSExport()
abstract class SubscriptionListener {
  /**
   * Event handler that is called by Lightstreamer each time a request to clear the snapshot pertaining to an item 
   * in the Subscription has been received from the Server. 
   * 
   * More precisely, this kind of request can occur in two cases:
   * <ul>
   *   <li>For an item delivered in COMMAND mode, to notify that the state of the item becomes empty; this is 
   *       equivalent to receiving an update carrying a DELETE command once for each key that is currently active.</li>
   *   <li>For an item delivered in DISTINCT mode, to notify that all the previous updates received for the item 
   *       should be considered as obsolete; hence, if the listener were showing a list of recent updates for the item, it 
   *       should clear the list in order to keep a coherent view.</li>
   * </ul>
   * Note that, if the involved Subscription has a two-level behavior enabled
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , the notification refers to the first-level item (which is in COMMAND mode).
   * This kind of notification is not possible for second-level items (which are in MERGE 
   * mode).
   * 
   * - [itemName] name of the involved item. If the Subscription was initialized using an "Item Group" then a 
   *        null value is supplied.
   * - [itemPos] 1-based position of the item within the "Item List" or "Item Group".
   */
  void onClearSnapshot(String itemName, int itemPos) {}
  /**
   * Event handler that is called by Lightstreamer to notify that, due to internal resource limitations, 
   * Lightstreamer Server dropped one or more updates for an item that was subscribed to as a second-level subscription. 
   * 
   * Such notifications are sent only if the Subscription was configured in unfiltered mode (second-level items are 
   * always in "MERGE" mode and inherit the frequency configuration from the first-level Subscription). <BR> 
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [lostUpdates] The number of consecutive updates dropped for the item.
   * - [key] The value of the key that identifies the second-level item.
   * 
   * - See [Subscription.setRequestedMaxFrequency]
   * - See [Subscription.setCommandSecondLevelFields]
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  void onCommandSecondLevelItemLostUpdates(int lostUpdates, String key) {}
  /**
   * Event handler that is called when the Server notifies an error on a second-level subscription.
   * 
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [errorCode] The error code sent by the Server. It can be one of the following:
   *        <ul>
   *          <li>14 - the key value is not a valid name for the Item to be subscribed; only in this case, the error 
   *              is detected directly by the library before issuing the actual request to the Server</li>
   *          <li>17 - bad Data Adapter name or default Data Adapter not defined for the current Adapter Set</li>
   *          <li>21 - bad Group name</li>
   *          <li>22 - bad Group name for this Schema</li>
   *          <li>23 - bad Schema name</li>
   *          <li>24 - mode not allowed for an Item</li>
   *          <li>26 - unfiltered dispatching not allowed for an Item, because a frequency limit is associated 
   *              to the item</li>
   *          <li>27 - unfiltered dispatching not supported for an Item, because a frequency prefiltering is 
   *              applied for the item</li>
   *          <li>28 - unfiltered dispatching is not allowed by the current license terms (for special licenses 
   *              only)</li>
   *          <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection</li>
   *          <li>68 - the Server could not fulfill the request because of an internal error.</li>
   *          <li>&lt;= 0 - the Metadata Adapter has refused the subscription or unsubscription request; the 
   *              code value is dependent on the specific Metadata Adapter implementation</li>
   *        </ul>
   *
   * - [errorMessage] The description of the error sent by the Server; it can be null.
   * - [key] The value of the key that identifies the second-level item.
   * 
   * - See [ConnectionDetails.setAdapterSet]
   * - See [Subscription.setCommandSecondLevelFields]
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  void onCommandSecondLevelSubscriptionError(int errorCode, String errorMessage, String key) {}
  /**
   * Event handler that is called by Lightstreamer to notify that all snapshot events for an item in the 
   * Subscription have been received, so that real time events are now going to be received. 
   * 
   * The received snapshot could be empty. Such notifications are sent only if the items are delivered in DISTINCT or COMMAND 
   * subscription mode and snapshot information was indeed requested for the items. By implementing this 
   * method it is possible to perform actions which require that all the initial values have been received. <BR>
   * Note that, if the involved Subscription has a two-level behavior enabled
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , the notification refers to the first-level item (which is in COMMAND mode).
   * Snapshot-related updates for the second-level items 
   * (which are in MERGE mode) can be received both before and after this notification.
   * 
   * - [itemName] name of the involved item. If the Subscription was initialized using an "Item Group" then a 
   *        null value is supplied.
   * - [itemPos] 1-based position of the item within the "Item List" or "Item Group".
   * 
   * - See [Subscription.setRequestedSnapshot]
   * - See [ItemUpdate.isSnapshot]
   */
  void onEndOfSnapshot(String itemName, int itemPos) {}
  /**
   * Event handler that is called by Lightstreamer to notify that, due to internal resource limitations, 
   * Lightstreamer Server dropped one or more updates for an item in the Subscription. 
   * 
   * Such notifications are sent only if the items are delivered in an unfiltered mode; this occurs if the 
   * subscription mode is:
   * <ul>
   *   <li>RAW</li>
   *   <li>MERGE or DISTINCT, with unfiltered dispatching specified</li>
   *   <li>COMMAND, with unfiltered dispatching specified</li>
   *   <li>COMMAND, without unfiltered dispatching specified (in this case, notifications apply to ADD 
   *       and DELETE events only)</li>
   * </ul>
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [itemName] name of the involved item. If the Subscription was initialized using an "Item Group" then a 
   *        null value is supplied.
   * - [itemPos] 1-based position of the item within the "Item List" or "Item Group".
   * - [lostUpdates] The number of consecutive updates dropped for the item.
   * 
   * - See [Subscription.setRequestedMaxFrequency]
   */
  void onItemLostUpdates(String itemName, int itemPos, int lostUpdates) {}
  /**
   * Event handler that is called by Lightstreamer each time an update pertaining to an item in the Subscription
   * has been received from the Server.
   * 
   * - [update] a value object containing the updated values for all the fields, together with meta-information 
   * about the update itself and some helper methods that can be used to iterate through all or new values.
   */
  void onItemUpdate(ItemUpdate update) {}
  /**
   * Event handler that receives a notification when the SubscriptionListener instance is removed from a Subscription 
   * through [Subscription.removeListener]. 
   * 
   * This is the last event to be fired on the listener.
   */
  void onListenEnd(void dummy) {}
  /**
   * Event handler that receives a notification when the SubscriptionListener instance is added to a Subscription 
   * through [Subscription.addListener]. 
   * 
   * This is the first event to be fired on the listener.
   */
  void onListenStart(void dummy) {}
  /**
   * Event handler that is called by Lightstreamer to notify the client with the real maximum update frequency of the Subscription. 
   * 
   * It is called immediately after the Subscription is established and in response to a requested change
   * (see [Subscription.setRequestedMaxFrequency]).
   * Since the frequency limit is applied on an item basis and a Subscription can involve multiple items,
   * this is actually the maximum frequency among all items. For Subscriptions with two-level behavior
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , the reported frequency limit applies to both first-level and second-level items. <BR>
   * The value may differ from the requested one because of restrictions operated on the server side,
   * but also because of number rounding. <BR>
   * Note that a maximum update frequency (that is, a non-unlimited one) may be applied by the Server
   * even when the subscription mode is RAW or the Subscription was done with unfiltered dispatching.
   * 
   * - [frequency]  A decimal number, representing the maximum frequency applied by the Server
   * (expressed in updates per second), or the string "unlimited". A null value is possible in rare cases,
   * when the frequency can no longer be determined.
   */
  void onRealMaxFrequency(String? frequency) {}
  /**
   * Event handler that is called by Lightstreamer to notify that a Subscription has been successfully subscribed 
   * to through the Server. 
   * 
   * This can happen multiple times in the life of a Subscription instance, in case the 
   * Subscription is performed multiple times through [LightstreamerClient.unsubscribe] and 
   * [LightstreamerClient.subscribe]. This can also happen multiple times in case of automatic 
   * recovery after a connection restart. <BR> 
   * This notification is always issued before the other ones related to the same subscription. It invalidates all 
   * data that has been received previously. <BR>
   * Note that two consecutive calls to this method are not possible, as before a second onSubscription event is 
   * fired an [onUnsubscription] event is eventually fired. <BR> 
   * If the involved Subscription has a two-level behavior enabled
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , second-level subscriptions are not notified.
   */
  void onSubscription() {}
  /**
   * Event handler that is called when the Server notifies an error on a Subscription. By implementing this method it 
   * is possible to perform recovery actions.
   * 
   * Note that, in order to perform a new subscription attempt, [LightstreamerClient.unsubscribe]
   * and [LightstreamerClient.subscribe] should be issued again, even if no change to the Subscription 
   * attributes has been applied.
   *
   * - [errorCode] The error code sent by the Server. It can be one of the following:
   *        <ul>
   *          <li>15 - "key" field not specified in the schema for a COMMAND mode subscription</li>
   *          <li>16 - "command" field not specified in the schema for a COMMAND mode subscription</li>
   *          <li>17 - bad Data Adapter name or default Data Adapter not defined for the current Adapter Set</li>
   *          <li>21 - bad Group name</li>
   *          <li>22 - bad Group name for this Schema</li>
   *          <li>23 - bad Schema name</li>
   *          <li>24 - mode not allowed for an Item</li>
   *          <li>25 - bad Selector name</li>
   *          <li>26 - unfiltered dispatching not allowed for an Item, because a frequency limit is associated 
   *              to the item</li>
   *          <li>27 - unfiltered dispatching not supported for an Item, because a frequency prefiltering is 
   *              applied for the item</li>
   *          <li>28 - unfiltered dispatching is not allowed by the current license terms (for special licenses 
   *              only)</li>
   *          <li>29 - RAW mode is not allowed by the current license terms (for special licenses only)</li>
   *          <li>30 - subscriptions are not allowed by the current license terms (for special licenses only)</li>
   *          <li>61 - there was an error in the parsing of the server response</li>
   *          <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection</li>
   *          <li>68 - the Server could not fulfill the request because of an internal error.</li>
   *          <li>&lt;= 0 - the Metadata Adapter has refused the subscription or unsubscription request; the 
   *              code value is dependent on the specific Metadata Adapter implementation</li>
   *        </ul>
   *
   * - [errorMessage] The description of the error sent by the Server; it can be null.
   * 
   * - See [ConnectionDetails.setAdapterSet]
   */
  void onSubscriptionError(int errorCode, String errorMessage) {}
  /**
   * Event handler that is called by Lightstreamer to notify that a Subscription has been successfully unsubscribed 
   * from. 
   * 
   * This can happen multiple times in the life of a Subscription instance, in case the Subscription is performed 
   * multiple times through [LightstreamerClient.unsubscribe] and 
   * [LightstreamerClient.subscribe]. This can also happen multiple times in case of automatic 
   * recovery after a connection restart. <BR>
   * After this notification no more events can be received until a new [onSubscription] event. <BR> 
   * Note that two consecutive calls to this method are not possible, as before a second onUnsubscription event 
   * is fired an [onSubscription] event is eventually fired. <BR> 
   * If the involved Subscription has a two-level behavior enabled
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , second-level unsubscriptions are not notified.
   */
  void onUnsubscription() {}

  late final _SubscriptionListener _that;
  SubscriptionListener() {
    _that = createDartExport(this) as _SubscriptionListener;
  }
  _SubscriptionListener get _asJSObject => _that;
  SubscriptionListener get _asDartObject => this;
}

/// A String or int value.
typedef StringOrInt = Object;

/**
 * Contains all the information related to an update of the field values for an item.
 *  
 * It reports all the new values of the fields. <BR>
 * 
 * <b>COMMAND Subscription</b><BR>
 * If the involved Subscription is a COMMAND Subscription, then the values for the current 
 * update are meant as relative to the same key. <BR>
 * Moreover, if the involved Subscription has a two-level behavior enabled, then each update 
 * may be associated with either a first-level or a second-level item. In this case, the reported 
 * fields are always the union of the first-level and second-level fields and each single update 
 * can only change either the first-level or the second-level fields (but for the "command" field, 
 * which is first-level and is always set to "UPDATE" upon a second-level update); note 
 * that the second-level field values are always null until the first second-level update 
 * occurs). When the two-level behavior is enabled, in all methods where a field name has to 
 * be supplied, the following convention should be followed:<BR>
 * <ul>
 *  <li>The field name can always be used, both for the first-level and the second-level fields. 
 *  In case of name conflict, the first-level field is meant.</li>
 *  <li>The field position can always be used; however, the field positions for the second-level 
 *  fields start at the highest position of the first-level field list + 1. If a field schema had 
 *  been specified for either first-level or second-level Subscriptions, then client-side knowledge 
 *  of the first-level schema length would be required.</li>
 *</ul>
 */
@JS()
@staticInterop
class ItemUpdate {}

extension ItemUpdateExt on ItemUpdate {
  @JS('forEachChangedField') external void _forEachChangedField(void Function(String? fieldName, int fieldPosition, String? value) callback);
  @JS('forEachField') external void _forEachField(void Function(String? fieldName, int fieldPosition, String? value) callback);
  /**
   * Inquiry method that retrieves the name of the item to which this update pertains.
   *  
   * The name will be null if the related Subscription was initialized using an "Item Group".
   * 
   * **Returns** The name of the item to which this update pertains.
   * - See [Subscription.setItemGroup]
   * - See [Subscription.setItems]
   */
  external String? getItemName();
  /**
   * Inquiry method that retrieves the position in the "Item List" or "Item Group" of the item to which this update pertains.
   * 
   * **Returns** The 1-based position of the item to which this update pertains.
   * - See [Subscription.setItemGroup]
   * - See [Subscription.setItems]
   */
  external int getItemPos();
  /**
   * Returns the current value for the specified field.
   * 
   * - [fieldNameOrPosition] The field name as specified within the "Field List" or the 1-based position of the field within the "Field List" or "Field Schema".
   * 
   * **Throws** IllegalArgumentException if the specified field is not part of the Subscription.
   * 
   * **Returns** The value of the specified field; it can be null in the following cases:<BR>
   * <ul>
   *  <li>a null value has been received from the Server, as null is a possible value for a field;</li>
   *  <li>no value has been received for the field yet;</li>
   *  <li>the item is subscribed to with the COMMAND mode and a DELETE command is received 
   *  (only the fields used to carry key and command information are valued).</li>
   * </ul>
   * - See [Subscription.setFields]
   */
  external String? getValue(StringOrInt fieldNameOrPosition);
  /**
   * Inquiry method that gets the difference between the new value and the previous one
   * as a JSON Patch structure, provided that the Server has used the JSON Patch format
   * to send this difference, as part of the "delta delivery" mechanism.
   * 
   * This, in turn, requires that:<ul>
   * <li>the Data Adapter has explicitly indicated JSON Patch as the privileged type of
   * compression for this field;</li>
   * <li>both the previous and new value are suitable for the JSON Patch computation
   * (i.e. they are valid JSON representations);</li>
   * <li>the item was subscribed to in MERGE or DISTINCT mode (note that, in case of
   * two-level behavior, this holds for all fields related with second-level items,
   * as these items are in MERGE mode);</li>
   * <li>sending the JSON Patch difference has been evaluated by the Server as more
   * efficient than sending the full new value.</li>
   * </ul>
   * Note that the last condition can be enforced by leveraging the Server's
   * &lt;jsonpatch_min_length&gt; configuration flag, so that the availability of the
   * JSON Patch form would only depend on the Client and the Data Adapter.
   * <BR>When the above conditions are not met, the method just returns null; in this
   * case, the new value can only be determined through [ItemUpdate.getValue]. For instance,
   * this will always be needed to get the first value received.
   * 
   * **Throws** IllegalArgumentException if the specified field is not
   * part of the Subscription.
   * 
   * - [fieldNameOrPosition] The field name as specified within the "Field List" or the 1-based position of the field within the "Field List" or "Field Schema".
   * 
   * **Returns** A JSON Patch structure representing the difference between
   * the new value and the previous one, or null if the difference in JSON Patch format
   * is not available for any reason.
   * 
   * - See [ItemUpdate.getValue]
   */
  external Object? getValueAsJSONPatchIfAvailable(StringOrInt fieldNameOrPosition);
  /**
   * Inquiry method that asks whether the current update belongs to the item snapshot (which carries the current item state at the time of Subscription). 
   * 
   * Snapshot events are sent only if snapshot 
   * information was requested for the items through [Subscription.setRequestedSnapshot]
   * and precede the real time events. Snapshot information take different forms in different 
   * subscription modes and can be spanned across zero, one or several update events. In particular:
   * <ul>
   *  <li>if the item is subscribed to with the RAW subscription mode, then no snapshot is 
   *  sent by the Server;</li>
   *  <li>if the item is subscribed to with the MERGE subscription mode, then the snapshot consists 
   *  of exactly one event, carrying the current value for all fields;</li>
   *  <li>if the item is subscribed to with the DISTINCT subscription mode, then the snapshot 
   *  consists of some of the most recent updates; these updates are as many as specified 
   *  through [Subscription#setRequestedSnapshot], unless fewer are available;</li>
   *  <li>if the item is subscribed to with the COMMAND subscription mode, then the snapshot 
   *  consists of an "ADD" event for each key that is currently present.</li>
   * </ul>
   * Note that, in case of two-level behavior, snapshot-related updates for both the first-level item
   * (which is in COMMAND mode) and any second-level items (which are in MERGE mode) are qualified with 
   * this flag.
   * 
   * **Returns** true if the current update event belongs to the item snapshot; false otherwise.
   */
  external bool isSnapshot();
  /**
   * Inquiry method that asks whether the value for a field has changed after the reception of the last update from the Server for an item. 
   * 
   * If the Subscription mode is COMMAND then the change is meant as 
   * relative to the same key.
   * - [fieldNameOrPosition] The field name as specified within the "Field List" or the 1-based position of the field within the "Field List" or "Field Schema".
   * 
   * **Throws** IllegalArgumentException if the specified field is not part of the Subscription.
   * 
   * **Returns** Unless the Subscription mode is COMMAND, the return value is true in the following cases:
   * <ul>
   *  <li>It is the first update for the item;</li>
   *  <li>the new field value is different than the previous field 
   *  value received for the item.</li>
   * </ul>
   *  If the Subscription mode is COMMAND, the return value is true in the following cases:
   * <ul>
   *  <li>it is the first update for the involved key value (i.e. the event carries an "ADD" command);</li>
   *  <li>the new field value is different than the previous field value received for the item, 
   *  relative to the same key value (the event must carry an "UPDATE" command);</li>
   *  <li>the event carries a "DELETE" command (this applies to all fields other than the field 
   *  used to carry key information).</li>
   * </ul>
   * In all other cases, the return value is false.
   * - See [Subscription.setFields]
   */
  external bool isValueChanged(StringOrInt fieldNameOrPosition);

  /**
   * Receives an iterator function and invokes it once per each field such that [ItemUpdate.isValueChanged] is true. 
   * 
   * Note that if the Subscription mode of the involved Subscription is 
   * COMMAND, then changed fields are meant as relative to the previous update 
   * for the same key. On such tables if a DELETE command is received, all the 
   * fields, excluding the key field, will be iterated as changed, with null value. All of this 
   * is also true on tables that have the two-level behavior enabled, but in 
   * case of DELETE commands second-level fields will not be iterated. 
   * 
   * Note that the iterator is executed before this method returns.
   * 
   * - [callback] iterator Function instance that will be called once 
   * per each field changed on the last update received from the server. 
   */
  void forEachChangedField(void Function(String? fieldName, int fieldPosition, String? value) callback) {
    _forEachChangedField(allowInterop(callback));
  }
  /**
   * Receives an iterator function and invokes it once per each field 
   * in the Subscription. 
   * 
   * Note that the iterator is executed before this method returns.
   * 
   * - [callback] iterator Function instance that will be called once 
   * per each field in the Subscription. 
   */
  void forEachField(void Function(String? fieldName, int fieldPosition, String? value) callback) {
    _forEachField(allowInterop(callback));
  }
}

/**
 * Class representing a Subscription to be submitted to a Lightstreamer Server. 
 *
 * It contains subscription details and the listeners needed to process the real-time data. <BR>
 * After the creation, a Subscription object is in the "inactive" state. When a Subscription 
 * object is subscribed to on a LightstreamerClient object, through the 
 * [LightstreamerClient.subscribe] method, its state becomes "active". 
 * This means that the client activates a subscription to the required items through 
 * Lightstreamer Server and the Subscription object begins to receive real-time events. <BR>
 * A Subscription can be configured to use either an Item Group or an Item List to specify the 
 * items to be subscribed to and using either a Field Schema or Field List to specify the fields. <BR>
 * "Item Group" and "Item List" are defined as follows:
 * <ul>
 *  <li>"Item Group": an Item Group is a String identifier representing a list of items. 
 *  Such Item Group has to be expanded into a list of items by the getItems method of the 
 *  MetadataProvider of the associated Adapter Set. When using an Item Group, items in the 
 *  subscription are identified by their 1-based index within the group.<BR>
 *  It is possible to configure the Subscription to use an "Item Group" using the 
 *  [setItemGroup] method.</li> 
 *  <li>"Item List": an Item List is an array of Strings each one representing an item. 
 *  For the Item List to be correctly interpreted a LiteralBasedProvider or a MetadataProvider 
 *  with a compatible implementation of getItems has to be configured in the associated 
 *  Adapter Set.<BR>
 *  Note that no item in the list can be empty, can contain spaces or can be a number.<BR>
 *  When using an Item List, items in the subscription are identified by their name or 
 *  by their 1-based index within the list.<BR>
 *  It is possible to configure the Subscription to use an "Item List" using the 
 *  [setItems] method or by specifying it in the constructor.</li>
 * </ul>
 * "Field Schema" and "Field List" are defined as follows:
 * <ul>
 *  <li>"Field Schema": a Field Schema is a String identifier representing a list of fields. 
 *  Such Field Schema has to be expanded into a list of fields by the getFields method of 
 *  the MetadataProvider of the associated Adapter Set. When using a Field Schema, fields 
 *  in the subscription are identified by their 1-based index within the schema.<BR>
 *  It is possible to configure the Subscription to use a "Field Schema" using the 
 *  [setFieldSchema] method.</li>
 *  <li>"Field List": a Field List is an array of Strings each one representing a field. 
 *  For the Field List to be correctly interpreted a LiteralBasedProvider or a MetadataProvider 
 *  with a compatible implementation of getFields has to be configured in the associated 
 *  Adapter Set.<BR>
 *  Note that no field in the list can be empty or can contain spaces.<BR>
 *  When using a Field List, fields in the subscription are identified by their name or 
 *  by their 1-based index within the list.<BR>
 *  It is possible to configure the Subscription to use a "Field List" using the 
 *  [setFields] method or by specifying it in the constructor.</li>
 * </ul>
 */
@JS()
@staticInterop
class Subscription {
  /**
   * Creates an object to be used to describe a Subscription that is going to be subscribed to 
   * through Lightstreamer Server. 
   * 
   * The object can be supplied to 
   * [LightstreamerClient.subscribe] and 
   * [LightstreamerClient.unsubscribe], in order to bring the Subscription 
   * to "active" or back to "inactive" state. <BR>
   * Note that all of the methods used to describe the subscription to the server can only be 
   * called while the instance is in the "inactive" state; the only exception is 
   * [Subscription.setRequestedMaxFrequency].
   *
   * - [mode] the subscription mode for the items, required by Lightstreamer Server. 
   * Permitted values are:
   * <ul>
   *  <li>MERGE</li>
   *  <li>DISTINCT</li>
   *  <li>RAW</li>
   *  <li>COMMAND</li>
   * </ul>
   * - [items] an array of items to be subscribed to through Lightstreamer server. <BR>
   * It is also possible specify the "Item List" or "Item Group" later through 
   * [Subscription.setItems] and [setItemGroup].
   * - [fields] an array of fields for the items to be subscribed to through Lightstreamer Server. <BR>
   * It is also possible to specify the "Field List" or "Field Schema" later through 
   * [Subscription.setFields] and [setFieldSchema].
   * 
   * **Throws** IllegalArgumentException If no or invalid subscription mode is passed.
   * 
   * **Throws** IllegalArgumentException If either the items or the fields array is left null.
   * 
   * **Throws** IllegalArgumentException If the specified "Item List" or "Field List" is not valid; 
   * see [Subscription.setItems] and [Subscription.setFields] for details.
   */
  external factory Subscription(String mode, [List<String>? items, List<String>? fields]);
}

extension SubscriptionExt on Subscription {
  @JS('addListener') external void _addListener(_SubscriptionListener listener);
  @JS('getListeners') external List<dynamic> _getListeners();
  @JS('removeListener') external void _removeListener(_SubscriptionListener listener);
  /**
   * Returns the position of the "command" field in a COMMAND Subscription.
   * 
   * This method can only be used if the Subscription mode is COMMAND and the Subscription 
   * was initialized using a "Field Schema".
   *
   * **Lifecycle** This method can be called at any time after the first 
   * [SubscriptionListener.onSubscription] event.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND or if the 
   * [SubscriptionListener.onSubscription] event for this Subscription was not 
   * yet fired.
   * 
   * **Throws** IllegalStateException if a "Field List" was specified.
   * 
   * **Returns** the 1-based position of the "command" field within the "Field Schema".
   */
  external int getCommandPosition();
  /**
   * Returns the position of the "key" field in a COMMAND Subscription.
   * 
   * This method can only be used if the Subscription mode is COMMAND
   * and the Subscription was initialized using a "Field Schema".
   *  
   * **Lifecycle** This method can be called at any time.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not 
   * COMMAND or if the [SubscriptionListener.onSubscription] event for this Subscription
   * was not yet fired.
   * 
   * **Returns** the 1-based position of the "key" field within the "Field Schema".
   */
  external int getKeyPosition();
  /**
   * Inquiry method that can be used to read the second-level Data Adapter name configured 
   * through [setCommandSecondLevelDataAdapter].
   *
   * **Lifecycle** This method can be called at any time.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the name of the second-level Data Adapter.
   * - See [setCommandSecondLevelDataAdapter]
   */
  external String? getCommandSecondLevelDataAdapter();
  /**
   * Setter method that sets the name of the second-level Data Adapter (within 
   * the Adapter Set used by the current session) that supplies all the 
   * second-level items.
   * 
   * All the possible second-level items should be supplied in "MERGE" mode 
   * with snapshot available. <BR> 
   * The Data Adapter name is configured on the server side through the 
   * "name" attribute of the &lt;data_provider&gt; element, in the "adapters.xml" 
   * file that defines the Adapter Set (a missing attribute configures the 
   * "DEFAULT" name).
   * 
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   *
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   *
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   *  
   * - See [Subscription.setCommandSecondLevelFields]
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  external void setCommandSecondLevelDataAdapter(String? dataAdapter);
  @JS('getCommandSecondLevelFields') external List<dynamic>? _getCommandSecondLevelFields();
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server for the second-level items. 
   *
   * It can only be used on COMMAND Subscriptions. <BR>
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified for the second-level. <BR>
   * Calling this method enables the two-level behavior:<BR>
   * in synthesis, each time a new key is received on the COMMAND Subscription, 
   * the key value is treated as an Item name and an underlying Subscription for
   * this Item is created and subscribed to automatically, to feed fields specified
   * by this method. This mono-item Subscription is specified through an "Item List"
   * containing only the Item name received. As a consequence, all the conditions
   * provided for subscriptions through Item Lists have to be satisfied. The item is 
   * subscribed to in "MERGE" mode, with snapshot request and with the same maximum
   * frequency setting as for the first-level items (including the "unfiltered" 
   * case). All other Subscription properties are left as the default. When the 
   * key is deleted by a DELETE command on the first-level Subscription, the 
   * associated second-level Subscription is also unsubscribed from. <BR> 
   * Specifying null as parameter will disable the two-level behavior.
   *       
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalArgumentException if any of the field names in the "Field List"
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   * 
   * - [fields] An array of Strings containing a list of fields to
   * be subscribed to through the server. <BR>
   * Ensure that no name conflict is generated between first-level and second-level
   * fields. In case of conflict, the second-level field will not be accessible
   * by name, but only by position.
   * 
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  external void setCommandSecondLevelFields(List<String>? fields);
  /**
   * Inquiry method that can be used to read the "Field Schema" specified for second-level 
   * Subscriptions.
   *
   * **Lifecycle** This method can only be called if the second-level of this Subscription has 
   * been initialized using a "Field Schema".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the Subscription was initialized with a "Field List" or was not initialized at all.
   * - See [Subscription.setCommandSecondLevelFieldSchema]
   */
  external String? getCommandSecondLevelFieldSchema();
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server for the second-level items. 
   *
   * It can only be used on COMMAND Subscriptions. <BR>
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified for the second-level. <BR>
   * Calling this method enables the two-level behavior:<BR>
   * in synthesis, each time a new key is received on the COMMAND Subscription, 
   * the key value is treated as an Item name and an underlying Subscription for
   * this Item is created and subscribed to automatically, to feed fields specified
   * by this method. This mono-item Subscription is specified through an "Item List"
   * containing only the Item name received. As a consequence, all the conditions
   * provided for subscriptions through Item Lists have to be satisfied. The item is 
   * subscribed to in "MERGE" mode, with snapshot request and with the same maximum
   * frequency setting as for the first-level items (including the "unfiltered" 
   * case). All other Subscription properties are left as the default. When the 
   * key is deleted by a DELETE command on the first-level Subscription, the 
   * associated second-level Subscription is also unsubscribed from. <BR>
   * Specify null as parameter will disable the two-level behavior.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalStateException if the Subscription mode is not "COMMAND".
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   * 
   * - See [Subscription.setCommandSecondLevelFields]
   */
  external void setCommandSecondLevelFieldSchema(String? schemaName);
  /**
   * Inquiry method that can be used to read the name of the Data Adapter specified for this 
   * Subscription through [setDataAdapter].
   
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the Data Adapter; returns null if no name has been configured, 
   * so that the "DEFAULT" Adapter Set is used.
   */
  external String? getDataAdapter();
  /**
   * Setter method that sets the name of the Data Adapter
   * (within the Adapter Set used by the current session)
   * that supplies all the items for this Subscription.
   *
   * The Data Adapter name is configured on the server side through
   * the "name" attribute of the "data_provider" element, in the
   * "adapters.xml" file that defines the Adapter Set (a missing attribute
   * configures the "DEFAULT" name). <BR>
   * Note that if more than one Data Adapter is needed to supply all the
   * items in a set of items, then it is not possible to group all the
   * items of the set in a single Subscription. Multiple Subscriptions
   * have to be defined.
   *
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   *  
   * - See [ConnectionDetails.setAdapterSet]
   */
  external void setDataAdapter(String? dataAdapter);
  @JS('getFields') external List<dynamic>? _getFields();
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalArgumentException if any of the field names in the list
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [fields] an array of fields to be subscribed to through the server. 
   */
  external void setFields(List<String>? fields);
  /**
   * Inquiry method that can be used to read the field schema specified for this Subscription.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized 
   * using a "Field Schema"
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the Subscription was initialized with a "Field List" or was not initialized at all.
   */
  external String? getFieldSchema();
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   */
  external void setFieldSchema(String? schemaName);
  /**
   * Inquiry method that can be used to read the item group specified for this Subscription.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized
   * using an "Item Group"
   * 
   * **Returns** the "Item Group" to be subscribed to through the server, or null if the Subscription was initialized with an "Item List" or was not initialized at all.
   */
  external String? getItemGroup();
  /**
   * Setter method that sets the "Item Group" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [groupName] A String to be expanded into an item list by the
   * Metadata Adapter. 
   */
  external void setItemGroup(String? groupName);
  @JS('getItems') external List<dynamic>? _getItems();
  /**
   * Setter method that sets the "Item List" to be subscribed to through 
   * Lightstreamer Server.
   *
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalArgumentException if any of the item names in the "Item List"
   * contains a space or is a number or is empty/null.
   *
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * - [items] an array of items to be subscribed to through the server. 
   */
  external void setItems(List<String>? items);
  /**
   * Inquiry method that can be used to read the mode specified for this
   * Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the Subscription mode specified in the constructor.
   */
  external String getMode();
  /**
   * Inquiry method that can be used to read the buffer size, configured though
   * [setRequestedBufferSize], to be requested to the Server for 
   * this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  An integer number, representing the buffer size to be requested to the server,
   * or the string "unlimited", or null.
   */
  external String? getRequestedBufferSize();
  /**
   * Setter method that sets the length to be requested to Lightstreamer
   * Server for the internal queuing buffers for the items in the Subscription.
   *
   * A Queuing buffer is used by the Server to accumulate a burst
   * of updates for an item, so that they can all be sent to the client,
   * despite of bandwidth or frequency limits. It can be used only when the
   * subscription mode is MERGE or DISTINCT and unfiltered dispatching has
   * not been requested. Note that the Server may pose an upper limit on the
   * size of its internal buffers.
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This means that the buffer size will be 1 for MERGE 
   * subscriptions and "unlimited" for DISTINCT subscriptions. See 
   * the "General Concepts" document for further details.
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor "unlimited" nor a valid positive integer number.
   *
   * - [size]  An integer number, representing the length of the internal queuing buffers
   * to be used in the Server. If the string "unlimited" is supplied, then no buffer
   * size limit is requested (the check is case insensitive). It is also possible
   * to supply a null value to stick to the Server default (which currently
   * depends on the subscription mode).
   *
   * - See [Subscription.setRequestedMaxFrequency]
   */
  external void setRequestedBufferSize(String? size);
  /**
   * Inquiry method that can be used to read the max frequency, configured
   * through [setRequestedMaxFrequency], to be requested to the 
   * Server for this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  A decimal number, representing the max frequency to be requested to the server
   * (expressed in updates per second), or the strings "unlimited" or "unfiltered", or null.
   */
  external String? getRequestedMaxFrequency();
  /**
   * Setter method that sets the maximum update frequency to be requested to
   * Lightstreamer Server for all the items in the Subscription. 
   *
   * It can be used only if the Subscription mode is MERGE, DISTINCT or
   * COMMAND (in the latter case, the frequency limitation applies to the
   * UPDATE events for each single key). For Subscriptions with two-level behavior
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * , the specified frequency limit applies to both first-level and second-level items. <BR>
   * Note that frequency limits on the items can also be set on the
   * server side and this request can only be issued in order to further
   * reduce the frequency, not to rise it beyond these limits. <BR>
   * This method can also be used to request unfiltered dispatching
   * for the items in the Subscription. However, unfiltered dispatching
   * requests may be refused if any frequency limit is posed on the server
   * side for some item.
   *
   * **General Edition Note** A further global frequency limit could also be imposed by the Server,
   * depending on Edition and License Type; this specific limit also applies to RAW mode and
   * to unfiltered dispatching.
   * To know what features are enabled by your license, please see the License tab of the
   * Monitoring Dashboard (by default, available at /dashboard).
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This consists, for all modes, in not applying any frequency 
   * limit to the subscription (the same as "unlimited"); see the "General Concepts"
   * document for further details.
   *
   * **Lifecycle** This method can can be called at any time with some
   * differences based on the Subscription status:
   * <ul>
   * <li>If the Subscription instance is in its "inactive" state then
   * this method can be called at will.</li>
   * <li>If the Subscription instance is in its "active" state then the method
   * can still be called unless the current value is "unfiltered" or the
   * supplied value is "unfiltered" or null.
   * If the Subscription instance is in its "active" state and the
   * connection to the server is currently open, then a request
   * to change the frequency of the Subscription on the fly is sent to the server.</li>
   * </ul>
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active" and the current value of this property is "unfiltered".
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active" and the given parameter is null or "unfiltered".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor one of the special "unlimited" and "unfiltered" values nor
   * a valid positive number.
   *
   * - [freq]  A decimal number, representing the maximum update frequency (expressed in updates
   * per second) for each item in the Subscription; for instance, with a setting
   * of 0.5, for each single item, no more than one update every 2 seconds
   * will be received. If the string "unlimited" is supplied, then no frequency
   * limit is requested. It is also possible to supply the string 
   * "unfiltered", to ask for unfiltered dispatching, if it is allowed for the 
   * items, or a null value to stick to the Server default (which currently
   * corresponds to "unlimited").
   * The check for the string constants is case insensitive.
   */
  external void setRequestedMaxFrequency(String? freq);
  /**
   * Inquiry method that can be used to read the snapshot preferences, 
   * configured through [setRequestedSnapshot], to be requested 
   * to the Server for this Subscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  "yes", "no", null, or an integer number.
   */
  external String? getRequestedSnapshot();
  /**
   * Setter method that enables/disables snapshot delivery request for the
   * items in the Subscription. 
   *
   * The snapshot can be requested only if the
   * Subscription mode is MERGE, DISTINCT or COMMAND.
   *
   * **Default** "yes" if the Subscription mode is not "RAW",
   * null otherwise.
   * 
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * "yes" nor "no" nor null nor a valid integer positive number.
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * compatible with the mode of the Subscription: 
   * <ul>
   *  <li>In case of a RAW Subscription only null is a valid value;</li>
   *  <li>In case of a non-DISTINCT Subscription only null "yes" and "no" are
   *  valid values.</li>
   * </ul>
   *
   * - [required] "yes"/"no" to request/not request snapshot
   * delivery (the check is case insensitive). If the Subscription mode is 
   * DISTINCT, instead of "yes", it is also possible to supply an integer number, 
   * to specify the requested length of the snapshot (though the length of 
   * the received snapshot may be less than requested, because of insufficient 
   * data or server side limits);
   * passing "yes"  means that the snapshot length should be determined
   * only by the Server. Null is also a valid value; if specified, no snapshot 
   * preference will be sent to the server that will decide itself whether
   * or not to send any snapshot. 
   * 
   * - See [ItemUpdate.isSnapshot]
   */
  external void setRequestedSnapshot(String? isRequired);
  /**
   * Inquiry method that can be used to read the selector name  
   * specified for this Subscription through [setSelector].
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the selector.
   */
  external String? getSelector();
  /**
   * Setter method that sets the selector name for all the items in the
   * Subscription. The selector is a filter on the updates received.
   *
   * It is executed on the Server and implemented by the Metadata Adapter.
   *
   * **Default** null (no selector).
   *
   * **Lifecycle** This method can only be called while the Subscription
   * instance is in its "inactive" state.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - [selector] name of a selector, to be recognized by the
   * Metadata Adapter, or null to unset the selector.
   */
  external void setSelector(String? selector);
  /**  
   * Inquiry method that checks if the Subscription is currently "active" or not.
   *
   * Most of the Subscription properties cannot be modified if a Subscription 
   * is "active". <BR>
   * The status of a Subscription is changed to "active" through the  
   * [LightstreamerClient.subscribe] method and back to 
   * "inactive" through the [LightstreamerClient.unsubscribe] one.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true/false if the Subscription is "active" or not.
   * 
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   */
  external bool isActive();
  /**  
   * Inquiry method that checks if the Subscription is currently subscribed to
   * through the server or not.
   *
   * This flag is switched to true by server sent Subscription events, and 
   * back to false in case of client disconnection, 
   * [LightstreamerClient.unsubscribe] calls and server 
   * sent unsubscription events. 
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true/false if the Subscription is subscribed to
   * through the server or not.
   */
  external bool isSubscribed();
  /**
   * Returns the latest value received for the specified item/field pair.
   *
   * It is suggested to consume real-time data by implementing and adding
   * a proper [SubscriptionListener] rather than probing this method. <BR>
   * In case of COMMAND Subscriptions, the value returned by this
   * method may be misleading, as in COMMAND mode all the keys received, being
   * part of the same item, will overwrite each other; for COMMAND Subscriptions,
   * use [getCommandValue] instead. <BR>
   * Note that internal data is cleared when the Subscription is 
   * unsubscribed from.
   *
   * **Lifecycle** This method can be called at any time; if called 
   * to retrieve a value that has not been received yet, then it will return null. 
   * 
   * **Throws** IllegalArgumentException if an invalid item name or field name is specified.
   * - [itemNameOrPosition] an item in the configured "Item List" or the 1-based position of an item within the configured "Item Group" or "Item List"
   * - [fieldNameOrPosition] a item in the configured "Field List" or the 1-based position of a field within the configured "Field Schema" or "Field List"
   * 
   * **Returns** the current value for the specified field of the specified item
   * (possibly null), or null if no value has been received yet.
   */
  external String? getValue(StringOrInt itemNameOrPosition, StringOrInt fieldNameOrPosition);
  /**
   * Returns the latest value received for the specified item/key/field combination.
   *  
   * This method can only be used if the Subscription mode is COMMAND. 
   * Subscriptions with two-level behavior
   * are also supported, hence the specified field 
   * (see [Subscription.setCommandSecondLevelFields] and [Subscription.setCommandSecondLevelFieldSchema])
   * can be either a first-level or a second-level one. <BR>
   * It is suggested to consume real-time data by implementing and adding a proper 
   * [SubscriptionListener] rather than probing this method. <BR>
   * Note that internal data is cleared when the Subscription is unsubscribed from.
   *
   * - [itemNameOrPosition] an item in the configured "Item List" or the 1-based position of an item within the configured "Item Group" or "Item List"
   * - [keyValue] the value of a key received on the COMMAND subscription.
   * - [fieldNameOrPosition] a item in the configured "Field List" or the 1-based position of a field within the configured "Field Schema" or "Field List"
   * 
   * **Throws** IllegalArgumentException if an invalid item name or field name is specified.
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND.
   * 
   * **Returns** the current value for the specified field of the specified key within the 
   * specified item (possibly null), or null if the specified key has not been added yet 
   * (note that it might have been added and then deleted).
   */
  external String? getCommandValue(StringOrInt itemNameOrPosition, String keyValue, StringOrInt fieldNameOrPosition);

  /**
   * Adds a listener that will receive events from the Subscription instance.
   * 
   * The same listener can be added to several different Subscription instances.
   *
   * **Lifecycle** A listener can be added at any time. A call to add a listener already 
   * present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the 
   * SubscriptionListener interface.
   * 
   * - See [removeListener]
   */
  void addListener(SubscriptionListener listener) {
    _addListener(listener._asJSObject);
  }
  /**
   * Removes a listener from the Subscription instance so that it will not receive 
   * events anymore.
   * 
   * **Lifecycle** a listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(SubscriptionListener listener) {
    _removeListener(listener._asJSObject);
  }
  /**
   * Returns a list containing the [SubscriptionListener] instances that were 
   * added to this client.
   *
   * **Returns** a list containing the listeners that were added to this client. 
   * - See [addListener]
   */
  List<SubscriptionListener> getListeners() {
    return _getListeners().map((obj) => (obj as _SubscriptionListener)._asDartObject).toList();
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for this Subscription.
   *
   * **Lifecycle**  This method can only be called if the Subscription has been initialized 
   * using a "Field List".
   * 
   * **Returns** the "Field List" to be subscribed to through the server, or null if the Subscription was initialized with a "Field Schema" or was not initialized at all.
   */
  List<String>? getFields() {
    return _getFields()?.cast<String>();
  }
  /**
   * Inquiry method that can be used to read the "Item List" specified for this Subscription. 
   *
   * Note that if the single-item-constructor was used, this method will return an array 
   * of length 1 containing such item.
   *
   * **Lifecycle** This method can only be called if the Subscription has been initialized 
   * with an "Item List".
   * 
   * **Returns** the "Item List" to be subscribed to through the server, or null if the Subscription was initialized with an "Item Group" or was not initialized at all.
   */
  List<String>? getItems() {
    return _getItems()?.cast<String>();
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for second-level 
   * Subscriptions.
   *
   * **Lifecycle** This method can only be called if the second-level of this Subscription 
   * has been initialized using a "Field List"
   * 
   * **Throws** IllegalStateException if the Subscription mode is not COMMAND
   * 
   * **Returns** the list of fields to be subscribed to through the server, or null if the Subscription was initialized with a "Field Schema" or was not initialized at all.
   * - See [Subscription.setCommandSecondLevelFields]
   */
  List<String>? getCommandSecondLevelFields() {
    return _getCommandSecondLevelFields()?.cast<String>();
  }
}

/**
 * Used by LightstreamerClient to provide a basic connection properties data object.
 *
 * Data object that contains the configuration settings needed
 * to connect to a Lightstreamer Server. <BR>
 * An instance of this class is attached to every [LightstreamerClient]
 * as [LightstreamerClient.connectionDetails]<BR>
 * 
 * - See LightstreamerClient
 */
@JS()
@staticInterop
class ConnectionDetails {}

extension ConnectionDetailsExt on ConnectionDetails {
  /**
   * Inquiry method that gets the name of the Adapter Set (which defines the Metadata Adapter and one or several 
   * Data Adapters) mounted on Lightstreamer Server that supply all the items used in this application.
   * 
   * **Returns** the adapterSet the name of the Adapter Set; returns null if no name has been configured, that 
   * means that the "DEFAULT" Adapter Set is used.
   * 
   * - See [setAdapterSet]
   */
  external String? getAdapterSet();
  /**
   * Setter method that sets the name of the Adapter Set mounted on Lightstreamer Server to be used to handle 
   * all requests in the session.
   * 
   * An Adapter Set defines the Metadata Adapter and one or several Data Adapters. It is configured on the 
   * server side through an "adapters.xml" file; the name is configured through the "id" attribute in 
   * the &lt;adapters_conf&gt; element.
   * 
   * **Default** The default Adapter Set, configured as "DEFAULT" on the Server.
   * 
   * **Lifecycle** The Adapter Set name should be set on the [LightstreamerClient.connectionDetails] object 
   * before calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: 
   * the supplied value will be used for the next time a new session is requested to the server. <BR>
   * This setting can also be specified in the [LightstreamerClient] constructor.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "adapterSet" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The name of the Adapter Set to be used. A null value is equivalent to the "DEFAULT" name.
   */
  external void setAdapterSet(String? newVal);
  /**
   * Inquiry method that gets the IP address of this client as seen by the Server which is serving the current session as the client remote address.
   * 
   * Note that it may not correspond to the client host.For instance, it may refer to an intermediate proxy. 
   * 
   * If, upon a new session, this address changes,
   * it may be a hint that the intermediary network nodes handling the connection have changed, hence the network
   * capabilities may be different. The library uses this information to optimize the connection. <BR>  
   * Note that in case of polling or in case rebind requests are needed, subsequent requests related to the same 
   * session may, in principle, expose a different IP address to the Server; these changes would not be reported.
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value may become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "clientIp" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns**  A canonical representation of an IP address (it can be either IPv4 or IPv6), or null.
   */
  external String? getClientIp();
  /**
   * Inquiry method that gets the configured address of Lightstreamer Server.
   *
   * **Returns** the serverAddress the configured address of Lightstreamer Server.
   */
  external String? getServerAddress();
  /**
   * Setter method that sets the address of Lightstreamer Server.
   * 
   * Note that the addresses specified must always have the http: or https: scheme. In case WebSockets are used, 
   * the specified scheme is internally converted to match the related WebSocket protocol (i.e. http becomes ws 
   * while https becomes wss).
   *
   * **General Edition Note** WSS/HTTPS is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** if no server address is supplied the client will be unable to connect.
   * 
   * **Lifecycle** This method can be called at any time. If called while connected, it will be applied when the next 
   * session creation request is issued. This setting can also be specified in the [LightstreamerClient]
   * constructor.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverAddress" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The full address of Lightstreamer Server. A null value can also be used, to restore the default value. 
   * An IPv4 or IPv6 can also be used in place of a hostname. Some examples of valid values include:
   * 
   * - `http://push.mycompany.com`
   * - `http://push.mycompany.com:8080`
   * - `http://79.125.7.252`
   * - `http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]`
   * - `http://[2001:0db8:85a3::8a2e:0370:7334]:8080`
   * 
   * **Throws** IllegalArgumentException if the given address is not valid.
   */
  external void setServerAddress(String? newVal);
  /**
   * Inquiry method that gets the server address to be used to issue all requests related to the current session. 
   * 
   * In fact, when a Server cluster is in place, the Server address specified through [setServerAddress] can 
   * identify various Server instances; in order to ensure that all requests related to a session are issued to 
   * the same Server instance, the Server can answer to the session opening request by providing an address which 
   * uniquely identifies its own instance. When this is the case, this address is returned by the method; otherwise,
   * null is returned. <BR> 
   * Note that the addresses will always have the http: or https: scheme. In case WebSockets are used, the specified 
   * scheme is internally converted to match the related WebSocket protocol (i.e. http becomes ws while 
   * https becomes wss).
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value may become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverInstanceAddress" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** address used to issue all requests related to the current session, or null.
   */
  external String? getServerInstanceAddress();
  /**
   * Inquiry method that gets the instance name of the Server which is serving the current session. 
   * 
   * To be more precise, 
   * each answering port configured on a Server instance (through a &lt;http_server&gt; or &lt;https_server&gt; element in the 
   * Server configuration file) can be given a different name; the name related to the port to which the session 
   * opening request has been issued is returned. <BR> 
   * Note that each rebind to the same session can, potentially, reach the Server on a port different than the one
   * used for the previous request, depending on the behavior of intermediate nodes. However, the only meaningful case
   * is when a Server cluster is in place and it is configured in such a way that the port used for all bind_session requests
   * differs from the port used for the initial create_session request.
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default, available at /dashboard).
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverSocketName" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** name configured for the Server instance which is managing the current session, or null.
   */
  external String? getServerSocketName();
  /**
   * Inquiry method that gets the ID associated by the server to this client session.
   * 
   * **Lifecycle** If a session is not currently active, null is returned;
   * soon after a session is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "sessionId" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns** ID assigned by the Server to this client session, or null.
   */
  external String? getSessionId();
  /**
   * Inquiry method that gets the username to be used for the authentication on Lightstreamer Server when initiating the session.
   * 
   * **Returns** the username to be used for the authentication on Lightstreamer Server; returns null if no 
   * user name has been configured.
   */
  external String? getUser();
  /**
   * Setter method that sets the username to be used for the authentication on Lightstreamer Server when initiating the session. 
   * 
   * The Metadata Adapter is responsible for checking the credentials (username and password).
   * 
   * **Default** If no username is supplied, no user information will be sent at session initiation. 
   * The Metadata Adapter, however, may still allow the session.
   * 
   * **Lifecycle** The username should be set on the [LightstreamerClient.connectionDetails] object before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the 
   * supplied value will be used for the next time a new session is requested to the server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "user" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The username to be used for the authentication on Lightstreamer Server. The username can be null.
   * 
   * - See [setPassword]
   */
  external void setUser(String? newVal);
  /**
   * Setter method that sets the password to be used for the authentication on Lightstreamer Server when initiating the session. 
   * 
   * The Metadata Adapter is responsible for checking the credentials (username and password).
   * 
   * **Default**  If no password is supplied, no password information will be sent at session initiation. 
   * The Metadata Adapter, however, may still allow the session.
   * 
   * **Lifecycle** The username should be set on the [LightstreamerClient.connectionDetails] object before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied 
   * value will be used for the next time a new session is requested to the server. <BR>
   * NOTE: The password string will be stored in the current instance. That is necessary in order to allow 
   * automatic reconnection/reauthentication for fail-over. For maximum security, avoid using an actual private 
   * password to authenticate on Lightstreamer Server; rather use a session-id originated by your web/application 
   * server, that can be checked by your Metadata Adapter.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "password" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The password to be used for the authentication on Lightstreamer Server. 
   *        The password can be null.
   *        
   * - See [setUser]
   */
  external void setPassword(String? newVal);
}

/**
 * Used by LightstreamerClient to provide an extra connection properties data object.
 *
 * Data object that contains the policy settings used to connect to a 
 * Lightstreamer Server. <BR>
 * An instance of this class is attached to every [LightstreamerClient]
 * as [LightstreamerClient.connectionOptions]<BR>
 * 
 * - See LightstreamerClient
 */
@JS()
@staticInterop
class ConnectionOptions {}

extension ConnectionOptionsExt on ConnectionOptions {
  /**
   * Inquiry method that gets the length expressed in bytes to be used by the Server for the response body on a HTTP stream connection.
   *
   * **Returns** The length to be used by the Server for the response body on a HTTP stream connection
   * - See [setContentLength]
   */
  external int getContentLength();
  /**
   * Setter method that sets the length in bytes to be used by the Server for the response body on a stream connection (a minimum length, however, is ensured by the server). 
   * 
   * After the content length exhaustion, the connection will
   * be closed and a new bind connection will be automatically reopened.<BR>
   * NOTE that this setting only applies to the "HTTP-STREAMING" case (i.e. not to WebSockets).
   * 
   * **Default** A length decided by the library, to ensure the best performance.
   * It can be of a few MB or much higher, depending on the environment.
   * 
   * **Lifecycle** The content length should be set before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will 
   * be used for the next streaming connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "contentLength" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The length to be used by the Server for the response body on a HTTP stream connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   */
  external void setContentLength(int newVal);
  /**
   * Inquiry method that gets the maximum time to wait before trying a new connection to the Server in case the previous one is unexpectedly closed while correctly working.
   *
   * **Returns** The max time (in milliseconds) to wait before trying a new connection.
   * - See [setFirstRetryMaxDelay]
   */
  external int getFirstRetryMaxDelay();
  /**
   * Setter method that sets the maximum time to wait before trying a new connection to the Server in case the previous one is unexpectedly closed while correctly working.
   * 
   * The new connection may be either the opening of a new session or an attempt to recovery
   * the current session, depending on the kind of interruption. <BR>
   * The actual delay is a randomized value between 0 and this value. 
   * This randomization might help avoid a load spike on the cluster due to simultaneous reconnections, should one of 
   * the active servers be stopped. Note that this delay is only applied before the first reconnection: should such 
   * reconnection fail, only the setting of [setRetryDelay] will be applied.
   * 
   * **Default** 100 (0.1 seconds)
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "firstRetryMaxDelay" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The max time (in milliseconds) to wait before trying a new connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   */
  external void setFirstRetryMaxDelay(int newVal);
  /**
   * Inquiry method that gets the value of the forced transport (if any).
   *
   * **Returns** The forced transport or null
   * - See [setForcedTransport]
   */
  external String? getForcedTransport();
  /**
   * Setter method that can be used to disable/enable the Stream-Sense algorithm and to force the client to use a fixed transport or a fixed combination of a transport and a connection type. 
   * 
   * When a combination is specified the 
   * Stream-Sense algorithm is completely disabled. <BR>
   * The method can be used to switch between streaming and polling connection types and between 
   * HTTP and WebSocket transports. <BR>
   * In some cases, the requested status may not be reached, because of connection or environment problems. In that case 
   * the client will continuously attempt to reach the configured status. <BR>
   * Note that if the Stream-Sense algorithm is disabled, the client may still enter the "CONNECTED:STREAM-SENSING" status; 
   * however, in that case, if it eventually finds out that streaming is not possible, no recovery will be tried.
   * 
   * **Default** null (full Stream-Sense enabled).
   * 
   * **Lifecycle** This method can be called at any time. If called while the client is connecting or connected it will instruct 
   * to switch connection type to match the given configuration.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "forcedTransport" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] can be one of the following: 
   * <ul>
   *  <li>null: the Stream-Sense algorithm is enabled and the client will automatically connect using the most 
   *  appropriate transport and connection type among those made possible by the environment.</li>
   *  <li>"WS": the Stream-Sense algorithm is enabled as in the null case but the client will only use WebSocket 
   *  based connections. If a connection over WebSocket is not possible because of the environment the client 
   *  will not connect at all.</li>
   *  <li>"HTTP": the Stream-Sense algorithm is enabled as in the null case but the client will only use HTTP based 
   *  connections. If a connection over HTTP is not possible because of the environment the client will not 
   *  connect at all.</li>
   *  <li>"WS-STREAMING": the Stream-Sense algorithm is disabled and the client will only connect on Streaming over 
   *  WebSocket. If Streaming over WebSocket is not possible because of the environment the client will not 
   *  connect at all.</li>
   *  <li>"HTTP-STREAMING": the Stream-Sense algorithm is disabled and the client will only connect on Streaming over HTTP. 
   *  If Streaming over HTTP is not possible because of the environment the client will not connect at all.</li>
   *  <li>"WS-POLLING": the Stream-Sense algorithm is disabled and the client will only connect on Polling over WebSocket. 
   *  If Polling over WebSocket is not possible because of the environment the client will not connect at all.</li>
   *  <li>"HTTP-POLLING": the Stream-Sense algorithm is disabled and the client will only connect on Polling over HTTP.
   *  If Polling over HTTP is not possible because of the environment the client will not connect at all.</li>
   * </ul>
   * 
   * **Throws** IllegalArgumentException if the given value is not in the list of the admitted ones.
   */
  external void setForcedTransport(String? newVal);
  @JS('getHttpExtraHeaders') external Object? _getHttpExtraHeaders();
  @JS('setHttpExtraHeaders') external void _setHttpExtraHeaders(Object? headers);
  /**
   * Inquiry method that gets the maximum time the Server is allowed to wait for any data to be sent in response to a polling request, if none has accumulated at request time. 
   * 
   * The wait time used by the Server, however, may be different, because of server side restrictions.
   *
   * **Returns** The time (in milliseconds) the Server is allowed to wait for data to send upon 
   * polling requests.
   * - See [setIdleTimeout]
   */
  external int getIdleTimeout();
  /**
   * Setter method that sets the maximum time the Server is allowed to wait for any data to be sent in response to a polling request, if none has accumulated at request time. 
   * 
   * Setting this time to a nonzero value and the polling interval 
   * to zero leads to an "asynchronous polling" behavior, which, on low data rates, is very similar to the streaming case.
   * Setting this time to zero and the polling interval to a nonzero value, on the other hand, leads to a classical 
   * "synchronous polling". <BR>
   * Note that the Server may, in some cases, delay the answer for more than the supplied time, to protect itself against
   * a high polling rate or because of bandwidth restrictions. Also, the Server may impose an upper limit on the wait time, 
   * in order to be able to check for client-side connection drops.
   * 
   * **Default**  19000 (19 seconds).
   * 
   * **Lifecycle** The idle timeout should be set before calling the 
   * [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value 
   * will be used for the next polling request.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "idleTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) the Server is allowed to wait for data to send upon polling requests.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   */
  external void setIdleTimeout(int newVal);
  /**
   * Inquiry method that gets the interval between two keepalive packets sent by Lightstreamer Server on a stream connection when no actual data is being transmitted. 
   * 
   * If the returned value is 0, it means that the interval is to be decided by the Server upon the next connection.
   * 
   * **Lifecycle** If the value has just been set and a connection to Lightstreamer Server has not been
   * established yet, the returned value is the time that is being requested to the Server.
   * Afterwards, the returned value is the time used by the Server, that may be different, because
   * of Server side constraints.
   * 
   * **Returns** The time, expressed in milliseconds, between two keepalive packets sent by the Server, or 0.
   * 
   * - See [setKeepaliveInterval]
   */
  external int getKeepaliveInterval();
  /**
   * Setter method that sets the interval between two keepalive packets to be sent by Lightstreamer Server on a stream connection when no actual data is being transmitted. 
   * 
   * The Server may, however, impose a lower limit on the keepalive 
   * interval, in order to protect itself. Also, the Server may impose an upper limit on the keepalive interval, in 
   * order to be able to check for client-side connection drops.
   * If 0 is specified, the interval will be decided by the Server.
   * 
   * **Default** 0 (meaning that the Server will send keepalive packets based on its own configuration).
   * 
   * **Lifecycle** The keepalive interval should be set before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied 
   * value will be used for the next streaming connection (either a bind or a brand new session). <BR>
   * Note that, after a connection, the value may be changed to the one imposed by the Server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "keepaliveInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   *
   * - [newVal] the keepalive interval time (in milliseconds) to set, or 0.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   * 
   * - See [setStalledTimeout]
   * - See [setReconnectTimeout]
   */
  external void setKeepaliveInterval(int newVal);
   /**
   * Inquiry method that gets the polling interval used for polling connections.
   * 
   * If the value has just been set and a polling request to Lightstreamer Server has not been performed 
   * yet, the returned value is the polling interval that is being requested to the Server. Afterwards, 
   * the returned value is the the time between subsequent polling requests that is really allowed by the 
   * Server, that may be different, because of Server side constraints.
   *
   * **Returns** The time (in milliseconds) between subsequent polling requests.
   * - See [setPollingInterval]
   */
  external int getPollingInterval();
  /**
   * Setter method that sets the polling interval used for polling connections. 
   * 
   * The client switches from the default streaming mode to polling mode when the client network infrastructure does not allow streaming. Also, 
   * polling mode can be forced by calling [setForcedTransport] with "WS-POLLING" or "HTTP-POLLING" 
   * as parameter. <BR>
   * The polling interval affects the rate at which polling requests are issued. It is the time between the start of a 
   * polling request and the start of the next request. However, if the polling interval expires before the first polling 
   * request has returned, then the second polling request is delayed. This may happen, for instance, when the Server delays 
   * the answer because of the idle timeout setting. In any case, the polling interval allows for setting an upper limit on 
   * the polling frequency. <BR> 
   * The Server does not impose a lower limit on the client polling interval. However, in some cases, it may protect itself
   * against a high polling rate by delaying its answer. Network limitations and configured bandwidth limits may also lower 
   * the polling rate, despite of the client polling interval. <BR>
   * The Server may, however, impose an upper limit on the polling interval, in order to be able to promptly detect 
   * terminated polling request sequences and discard related session information.
   * 
   * **Default** 0 (pure "asynchronous polling" is configured).
   * 
   * **Lifecycle** The polling interval should be set before calling 
   * the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will
   * be used for the next polling request. <BR>
   * Note that, after each polling request, the value may be changed to the one imposed by the Server.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "pollingInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) between subsequent polling requests. Zero is a legal value too, 
   * meaning that the client will issue a new polling request as soon as a previous one has returned.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured 
   */
  external void setPollingInterval(int newVal);
  /**
   * Inquiry method that gets the maximum bandwidth that can be consumed for the data coming from Lightstreamer Server. 
   * 
   * This is the actual maximum bandwidth, in contrast with the requested
   * maximum bandwidth, returned by [getRequestedMaxBandwidth]. <BR>
   * The value may differ from the requested one because of restrictions operated on the server side,
   * or because bandwidth management is not supported (in this case it is always "unlimited"),
   * but also because of number rounding.
   * 
   * **Lifecycle** If a connection to Lightstreamer Server is not currently active, null is returned;
   * soon after the connection is established, the value will become available.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "realMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * **Returns**  A decimal number, which represents the maximum bandwidth applied by the Server for the
   * streaming or polling connection expressed in kbps (kilobits/sec), or the string "unlimited", or null.
   * - See [setRequestedMaxBandwidth]
   */
  external String? getRealMaxBandwidth();
  /**
   * Inquiry method that gets the time the client, after entering "STALLED" status,
   * is allowed to keep waiting for a keepalive packet or any data on a stream connection,
   * before disconnecting and trying to reconnect to the Server.
   *
   * **Returns** The idle time (in milliseconds) admitted in "STALLED" status before trying to 
   * reconnect to the Server.
   * - See [setReconnectTimeout]
   */
  external int getReconnectTimeout();
  /**
   * Setter method that sets the time the client, after entering "STALLED" status,
   * is allowed to keep waiting for a keepalive packet or any data on a stream connection,
   * before disconnecting and trying to reconnect to the Server.
   * 
   * The new connection may be either the opening of a new session or an attempt to recovery
   * the current session, depending on the kind of interruption.
   * 
   * **Default** 3000 (3 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "reconnectTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The idle time (in milliseconds) allowed in "STALLED" status before trying
   * to reconnect to the Server.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setStalledTimeout]
   * - See [setKeepaliveInterval]
   */
  external void setReconnectTimeout(int newVal);
  /**
   * Inquiry method that gets the maximum bandwidth that can be consumed for the data coming from Lightstreamer Server, as requested for this session.
   * 
   * The maximum bandwidth limit really applied by the Server on the session is provided by
   * [getRealMaxBandwidth]
   * 
   * **Returns**  A decimal number, which represents the maximum bandwidth requested for the streaming
   * or polling connection expressed in kbps (kilobits/sec), or the string "unlimited".
   * - See [setRequestedMaxBandwidth]
   */
  external String getRequestedMaxBandwidth();
  /**
   * Setter method that sets the maximum bandwidth expressed in kilobits/s that can be consumed for the data coming from Lightstreamer Server. 
   * 
   * A limit on bandwidth may already be posed by the Metadata Adapter, but the client can 
   * further restrict this limit. The limit applies to the bytes received in each streaming or polling connection.
   * 
   * **General Edition Note** Bandwidth Control is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** "unlimited"
   * 
   * **Lifecycle** The bandwidth limit can be set and changed at any time. If a connection is currently active, the bandwidth 
   * limit for the connection is changed on the fly. Remember that the Server may apply a different limit.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "requestedMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient. <BR>
   * Moreover, upon any change or attempt to change the limit, the Server will notify the client
   * and such notification will be received through a call to 
   * [ClientListener.onPropertyChange] with argument "realMaxBandwidth" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal]  A decimal number, which represents the maximum bandwidth requested for the streaming
   * or polling connection expressed in kbps (kilobits/sec). The string "unlimited" is also allowed, to mean that
   * the maximum bandwidth can be entirely decided on the Server side (the check is case insensitive).
   * 
   * **Throws** IllegalArgumentException if a negative, zero, or a not-number value (excluding special values) is passed.
   * 
   * - See [getRealMaxBandwidth]
   */
  external void setRequestedMaxBandwidth(String newVal);
  /**
   * Inquiry method that gets the minimum time to wait before trying a new connection
   * to the Server in case the previous one failed for any reason, which is also the maximum time to wait for a response to a request before dropping the connection and trying with a different approach.
   * 
   * Note that the delay is calculated from the moment the effort to create a connection
   * is made, not from the moment the failure is detected or the connection timeout expires.
   *
   * **Returns** The time (in milliseconds) to wait before trying a new connection.
   * - See [setRetryDelay]
   */
  external int getRetryDelay();
  /** 
   * Setter method that sets 
   * <ol>
   * <li>the minimum time to wait before trying a new connection
   * to the Server in case the previous one failed for any reason; and</li>
   * <li>the maximum time to wait for a response to a request 
   * before dropping the connection and trying with a different approach.</li>
   * </ol>
   * 
   * Enforcing a delay between reconnections prevents strict loops of connection attempts when these attempts
   * always fail immediately because of some persisting issue.
   * This applies both to reconnections aimed at opening a new session and to reconnections
   * aimed at attempting a recovery of the current session.<BR>
   * Note that the delay is calculated from the moment the effort to create a connection
   * is made, not from the moment the failure is detected.
   * As a consequence, when a working connection is interrupted, this timeout is usually
   * already consumed and the new attempt can be immediate (except that
   * [ConnectionOptions.setFirstRetryMaxDelay] will apply in this case).
   * As another consequence, when a connection attempt gets no answer and times out,
   * the new attempt will be immediate.<BR>
   * <BR>
   * As a timeout on unresponsive connections, it is applied in these cases:
   * <ul>
   * <li><i>Streaming</i>: Applied on any attempt to setup the streaming connection. If after the 
   * timeout no data has arrived on the stream connection, the client may automatically switch transport 
   * or may resort to a polling connection.</li>
   * <li><i>Polling and pre-flight requests</i>: Applied on every connection. If after the timeout 
   * no data has arrived on the polling connection, the entire connection process restarts from scratch.</li>
   * </ul>
   * <BR>
   * <b>This setting imposes only a minimum delay. In order to avoid network congestion, the library may use a longer delay if the issue preventing the
   * establishment of a session persists.</b>
   * 
   * **Default** 4000 (4 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "retryDelay" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The time (in milliseconds) to wait before trying a new connection.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setFirstRetryMaxDelay]
   */
  external void setRetryDelay(int newVal);
  /**
   * Inquiry method that gets the reverse-heartbeat interval expressed in milliseconds.
   * 
   * A 0 value is possible, meaning that the mechanism is disabled.
   *
   * **Returns** The reverse-heartbeat interval, or 0.
   * - See [setReverseHeartbeatInterval]
   */
  external int getReverseHeartbeatInterval();
  /**
   * Setter method that enables/disables the reverse-heartbeat mechanism by setting the
   * heartbeat interval. 
   * 
   * If the given value (expressed in milliseconds) equals 0 then the reverse-heartbeat mechanism will be disabled; otherwise if the given value is greater than 0 the mechanism will be enabled with the specified interval.
   * 
   * When the mechanism is active, the client will ensure that there
   * is at most the specified interval between a control request and the following one,
   * by sending empty control requests (the "reverse heartbeats") if necessary.
   * <BR>This can serve various purposes:<ul>
   * <li>Preventing the communication infrastructure from closing an inactive socket
   * that is ready for reuse for more HTTP control requests, 
   * to avoid connection reestablishment overhead. However it is not guaranteed that the connection will be kept open,
   * as the underlying TCP implementation may open a new socket each time a HTTP request needs to be sent.<BR>
   * Note that this will be done only when a session is in place.</li>
   * <li>Allowing the Server to detect when a streaming connection or Websocket
   * is interrupted but not closed. In these cases, the client eventually closes
   * the connection, but the Server cannot see that (the connection remains "half-open")
   * and just keeps trying to write. This is done by notifying the timeout to the Server
   * upon each streaming request. For long polling, the [setIdleTimeout] setting
   * has a similar function.</li>
   * <li>Allowing the Server to detect cases in which the client has closed a connection
   * in HTTP streaming, but the socket is kept open by some intermediate node,
   * which keeps consuming the response.
   * This is also done by notifying the timeout to the Server upon each streaming request,
   * whereas, for long polling, the [setIdleTimeout] setting has a similar function.</li>
   * </ul>
   * 
   * **Default** 0 (meaning that the mechanism is disabled).
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the setting will be obeyed immediately, unless a higher heartbeat
   * frequency was notified to the Server for the current connection. The setting
   * will always be obeyed upon the next connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "reverseHeartbeatInterval" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] the interval, expressed in milliseconds, between subsequent reverse-heartbeats, or 0.
   * 
   * **Throws** IllegalArgumentException if a negative value is configured
   */
  external void setReverseHeartbeatInterval(int newVal);
  /**
   * Inquiry method that gets the maximum time allowed for attempts to recover
   * the current session upon an interruption, after which a new session will be created.
   * 
   * A 0 value also means that any attempt to recover the current session is prevented
   * in the first place.
   * 
   * **Returns** The maximum time allowed for recovery attempts, possibly 0.
   * - See [setSessionRecoveryTimeout]
   */
  external int getSessionRecoveryTimeout();
  /**
   * Setter method that sets the maximum time allowed for attempts to recover
   * the current session upon an interruption, after which a new session will be created.
   * 
   * If the given value (expressed in milliseconds) equals 0, then any attempt
   * to recover the current session will be prevented in the first place.
   * <BR>In fact, in an attempt to recover the current session, the client will
   * periodically try to access the Server at the address related with the current
   * session. In some cases, this timeout, by enforcing a fresh connection attempt,
   * may prevent an infinite sequence of unsuccessful attempts to access the Server.
   * <BR>Note that, when the Server is reached, the recovery may fail due to a
   * Server side timeout on the retention of the session and the updates sent.
   * In that case, a new session will be created anyway.
   * A setting smaller than the Server timeouts may prevent such useless failures,
   * but, if too small, it may also prevent successful recovery in some cases.
   * 
   * **Default** 15000 (15 seconds).
   * 
   * **Lifecycle** This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a
   * call to [ClientListener.onPropertyChange] with argument "sessionRecoveryTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The maximum time allowed
   * for recovery attempts, expressed in milliseconds, including 0.
   *
   * **Throws** IllegalArgumentException if a negative value is passed.
   */
  external void setSessionRecoveryTimeout(int newVal);
  /**
   * Inquiry method that gets the extra time the client can wait when an expected keepalive packet has not been received on a stream connection (and no actual data has arrived), before entering the "STALLED" status.
   *
   * **Returns** The idle time (in milliseconds) admitted before entering the "STALLED" status.
   * - See [setStalledTimeout]
   */
  external int getStalledTimeout();
  /**
   * Setter method that sets the extra time the client is allowed to wait when an expected keepalive packet has not been received on a stream connection (and no actual data has arrived), before entering the "STALLED" status.
   * 
   * **Default** 2000 (2 seconds).
   * 
   * **Lifecycle**  This value can be set and changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "stalledTimeout" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] The idle time (in milliseconds) allowed before entering the "STALLED" status.
   * 
   * **Throws** IllegalArgumentException if a negative or zero value is configured 
   * 
   * - See [setReconnectTimeout]
   * - See [setKeepaliveInterval]
   */
  external void setStalledTimeout(int newVal);
  /**  
   * Inquiry method that checks if the client is going to connect only if it
   * can guarantee that cookies pertaining to the server will be sent.
   *
   * **Returns** true/false if the cookies-are-required policy is enabled or not.
   * 
   * - See [setCookieHandlingRequired]
   */
  external bool isCookieHandlingRequired();
  /**
   * Setter method that enables/disables the cookies-are-required policy on the 
   * client side.
   * 
   * Enabling this policy will guarantee that cookies pertaining to the 
   * Lightstreamer Server will be sent with each request.
   * 
   * This holds for both cookies returned by the Server (possibly affinity cookies
   * inserted by a Load Balancer standing in between) and for cookies set by
   * other sites (for instance on the front-end page) and with a domain
   * specification which includes Lightstreamer Server host.
   * Likewise, cookies set by Lightstreamer Server and with a domain
   * specification which includes other sites will be forwarded to them.
   * 
   * On the other hand enabling this setting may prevent the client from
   * opening a streaming connection or even to connect at all depending on the
   * browser/environment.
   * 
   * **Default** false
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the supplied value will be used for the next HTTP request or WebSocket establishment.
   * 
   * **Notification** A change to this setting will be notified through a
   * call to [ClientListener.onPropertyChange] with argument "cookieHandlingRequired" on any 
   * [ClientListener].
   * 
   * - [cookieHandlingRequired] true/false to enable/disable the 
   * cookies-are-required policy.
   */
  external void setCookieHandlingRequired(bool cookieHandlingRequired);
  /**
   * Inquiry method that checks if the restriction on the forwarding of the configured extra http headers applies or not. 
   *
   * **Returns** the httpExtraHeadersOnSessionCreationOnly
   * - See [setHttpExtraHeadersOnSessionCreationOnly]
   * - See [setHttpExtraHeaders]
   */
  external bool isHttpExtraHeadersOnSessionCreationOnly();
  /**
   * Setter method that enables/disables a restriction on the forwarding of the extra http headers specified through [setHttpExtraHeaders]. 
   * 
   * If true, said headers will only be sent during the session creation 
   * process (and thus will still be available to the metadata adapter notifyUser method) but will not be sent on following 
   * requests. On the contrary, when set to true, the specified extra headers will be sent to the server on every request.
   * 
   * **Default** false
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the supplied value will be used for the next HTTP request or WebSocket establishment.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "httpExtraHeadersOnSessionCreationOnly" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true/false to enable/disable the restriction on extra headers forwarding.
   */
  external void setHttpExtraHeadersOnSessionCreationOnly(bool newVal);
  /**
   * Inquiry method that checks if the client is going to ignore the server instance address that will possibly be sent by the server.
   *
   * **Returns** Whether or not to ignore the server instance address sent by the server.
   * - See [setServerInstanceAddressIgnored]
   */
  external bool isServerInstanceAddressIgnored();
  /**
   * Setter method that can be used to disable/enable the automatic handling of server instance address that may be returned by the Lightstreamer server during session creation.
   * 
   * In fact, when a Server cluster is in place, the Server address specified through 
   * [ConnectionDetails.setServerAddress] can identify various Server instances; in order to 
   * ensure that all requests related to a session are issued to the same Server instance, the Server can answer
   * to the session opening request by providing an address which uniquely identifies its own instance. <BR> 
   * Setting this value to true permits to ignore that address and to always connect through the address 
   * supplied in setServerAddress. This may be needed in a test environment, if the Server address specified 
   * is actually a local address to a specific Server instance in the cluster. <BR>
   * 
   * **General Edition Note** Server Clustering is an optional feature, available depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the Monitoring Dashboard (by default,
   * available at /dashboard).
   * 
   * **Default** false.
   * 
   * **Lifecycle** This method can be called at any time. If called while connected, it will be applied when the 
   * next session creation request is issued.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "serverInstanceAddressIgnored" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true or false, to ignore or not the server instance address sent by the server.
   * 
   * - See [ConnectionDetails.setServerAddress]
   */
  external void setServerInstanceAddressIgnored(bool newVal);
  /**
   * Inquiry method that checks if the slowing algorithm is enabled or not.
   *
   * **Returns** Whether the slowing algorithm is enabled or not.
   * - See [setSlowingEnabled]
   */
  external bool isSlowingEnabled();
  /**
   * Setter method that turns on or off the slowing algorithm. 
   * 
   * This heuristic algorithm tries to detect when the client 
   * CPU is not able to keep the pace of the events sent by the Server on a streaming connection. In that case, an automatic
   * transition to polling is performed. <BR>
   * In polling, the client handles all the data before issuing the next poll, hence a slow client would just delay the polls, 
   * while the Server accumulates and merges the events and ensures that no obsolete data is sent. <BR>
   * Only in very slow clients, the next polling request may be so much delayed that the Server disposes the session first, 
   * because of its protection timeouts. In this case, a request for a fresh session will be reissued by the client and this 
   * may happen in cycle.
   * 
   * **Default** false.
   * 
   * **Lifecycle** This setting should be performed before 
   * calling the [LightstreamerClient.connect] method. However, the value can be changed at any time: the supplied value will 
   * be used for the next streaming connection (either a bind or a brand new session).
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "slowingEnabled" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] true or false, to enable or disable the heuristic algorithm that lowers the item update frequency.
   */
  external void setSlowingEnabled(bool newVal);

  /**
   * Inquiry method that gets the Map object containing the extra headers to be sent to the server.
   *
   * **Returns** The Map object containing the extra headers to be sent
   * - See [setHttpExtraHeaders]
   * - See [setHttpExtraHeadersOnSessionCreationOnly]
   */
  Map<String, String>? getHttpExtraHeaders() {
    return (dartify(_getHttpExtraHeaders()) as Map<dynamic, dynamic>).cast<String, String>();
  }
  /**
   * Setter method that enables/disables the setting of extra HTTP headers to all the request performed to the Lightstreamer server by the client.
   * 
   * Note that the Content-Type header is reserved by the client library itself, while other headers might be refused by the 
   * environment and others might cause the connection to the server to fail.
   * <BR> For instance, you cannot use this method to specify custom cookies to be sent to
   * Lightstreamer Server; leverage [LightstreamerClient.addCookies] instead.
   * The use of custom headers might also cause the
   * client to send an OPTIONS request to the server before opening the actual connection. 
   * 
   * **Default** null (meaning no extra headers are sent).
   * 
   * **Lifecycle** This setting should be performed before calling the
   * [LightstreamerClient.connect] method. However, the value can be changed
   * at any time: the supplied value will be used for the next HTTP request or WebSocket establishment.
   * 
   * **Notification** A change to this setting will be notified through a call to 
   * [ClientListener.onPropertyChange] with argument "httpExtraHeaders" on any 
   * ClientListener listening to the related LightstreamerClient.
   * 
   * - [newVal] a Map object containing header-name header-value pairs. Null can be specified to avoid extra 
   * headers to be sent.
   */
  void setHttpExtraHeaders(Map<String, String>? headers) {
    _setHttpExtraHeaders(jsify(headers));
  }
}

/**
  Simple concrete logging provider that logs on the system console.
 
  To be used, an instance of this class has to be passed to the library through the [LightstreamerClient.setLoggerProvider].
 */
@JS()
@staticInterop
class ConsoleLoggerProvider extends LoggerProvider {
  /**
    Creates an instance of the concrete system console logger.
     
    - [level] The desired logging level. See [ConsoleLogLevel].
  */
  external factory ConsoleLoggerProvider(int level);
}

/**
 Logging level.
 */
@JS()
@staticInterop
class ConsoleLogLevel {
  /**
    Debug logging level.
     
    This level enables all logging except tracing.
   */
  external static int DEBUG;
  /**
    Error logging level.
     
    This level enables logging for errors and fatal errors.
   */
  external static int ERROR;
  /**
    Fatal logging level.
     
    This level enables logging for fatal errors only.
   */
  external static int FATAL;
  /**
    Info logging level.
     
    This level enables logging for information, warnings, errors and fatal errors.
   */
  external static int INFO;
  /**
    Trace logging level.
   
    This level enables all logging.
   */
  external static int TRACE;
  /**
    Warn logging level.
     
    This level enables logging for warnings, errors and fatal errors.
   */
  external static int WARN;
}

/** 
 * Simple interface to be implemented to provide custom log consumers to the library.
 * 
 * An instance of the custom implemented class has to be passed to the library through the 
 * [LightstreamerClient.setLoggerProvider].
 */
@JS()
@staticInterop
class LoggerProvider {}

/**
 * Class representing a device that supports Mobile Push Notifications (MPN).
 * 
 * It contains device details and the listener needed to monitor its status.<BR>
 * An MPN device is created from the application context, the sender ID (a.k.a. authorized entity) and a device token (a.k.a. registration token) obtained from 
 * Firebase Cloud Messaging APIs, and must be registered on the [LightstreamerClient] in order to successfully subscribe an MPN subscription. 
 * See [MpnSubscription].<BR>
 * After creation, an MpnDevice object is in "unknown" state. It must then be passed to the Lightstreamer Server with the
 * [LightstreamerClient.registerForMpn] method, which enables the client to subscribe MPN subscriptions and sends the device details to the
 * server's MPN Module, where it is assigned a permanent device ID and its state is switched to "registered".<BR>
 * Upon registration on the server, active MPN subscriptions of the device are received and exposed with the [LightstreamerClient.getMpnSubscriptions]
 * method.<BR>
 * An MpnDevice's state may become "suspended" if errors occur during push notification delivery. In this case MPN subscriptions stop sending notifications
 * and the device state is reset to "registered" at the first subsequent registration.
 */
@JS()
@staticInterop
class MpnDevice {
  /**
	 * Creates an object to be used to describe an MPN device that is going to be registered to the MPN Module of Lightstreamer Server.
   * 
   * During creation the MpnDevice tries to acquires any previously registered device token from localStorage.
   * It then saves the current device token on localStorage. Saving and retrieving the previous device token is used to handle automatically
   * the cases where the token changes. The MPN Module of Lightstreamer Server is able to move
   * MPN subscriptions associated with the previous token to the new one.
   *
   * - [token] the device token
   * - [appId] the application identifier
   * - [platform] either "Google" for Google's Firebase Cloud Messaging (FCM) or "Apple" for Apple Push Notification Service (APNs)
   *
   * **Throws** IllegalArgumentException if <code>token</code> or <code>appId</code> is null or <code>platform</code> is not "Google" or "Apple".
   */
  external factory MpnDevice(String token, String appId, String platform);
}

extension MpnDeviceExt on MpnDevice {
  @JS('addListener') external void _addListener(_MpnDeviceListener listener);
  @JS('getListeners') external List<dynamic> _getListeners();
  @JS('removeListener') external void _removeListener(_MpnDeviceListener listener);
  /**
   * The application ID of this MPN device, corresponding to the package name of the application. In the [MpnDevice]
   * implementation it is determined automatically from the Application Context during creation and is used by the server as part of the device identification.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device application ID.
   */
  external String getApplicationId();
  /**
   * The server-side unique persistent ID of the device.
   * 
   * The ID is available only after the MPN device object has been successfully registered on the server. I.e. when its status is <code>REGISTERED</code> or
   * <code>SUSPENDED</code>.<BR>
   * Note: a device token change, if the previous device token was correctly stored on the Shared Preferences storage, does not cause the device ID to change: the
   * server moves previous MPN subscriptions from the previous token to the new one and the device ID remains unaltered.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device ID.
   */
  external String? getDeviceId();
  /**
   * The device token of this MPN device. 
   * 
   * In the [MpnDevice] implementation it is passed during creation and 
   * is used by the server as part of the device identification.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device token.
   */
  external String getDeviceToken();
  /**
   * The platform identifier of this MPN device. 
   * 
   * In the [MpnDevice] implementation it equals to the constant <code>Google</code>
   * and is used by the server as part of the device identification.
   *  
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN device platform.
   */
  external String getPlatform();
  /**
   * The previous device token of this MPN device. 
   * 
   * In the [MpnDevice] implementation it is obtained automatically from 
   * the Shared Preferences storage during creation and is used by the server to restore MPN subscriptions associated with this previous token. May be null if 
   * no MPN device has been registered yet on the application.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the previous MPN device token, or null if no MPN device has been registered yet.
   */
  external String? getPreviousDeviceToken();
  /**
   * The status of the device.
   * 
   * The status can be:<ul>
   * <li><code>UNKNOWN</code>: when the MPN device object has just been created or deleted. In this status [isRegistered] and [isSuspended] are both false.</li>
   * <li><code>REGISTERED</code>: when the MPN device object has been successfully registered on the server. In this status [isRegistered] is true and
   * [isSuspended] is false.</li>
   * <li><code>SUSPENDED</code>: when a server error occurred while sending push notifications to this MPN device and consequently it has been suspended. In this status 
   * [isRegistered] and [isSuspended] are both true.</li>
   * </ul>
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the status of the device.
   * 
   * - See [isRegistered]
   * - See [isSuspended]
   */
  external String getStatus();
  /**
   * The server-side timestamp of the device status.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** The server-side timestamp of the device status.
   * 
   * - See [getStatus]
   */
  external int getStatusTimestamp();
  /**
   * Checks whether the MPN device object is currently registered on the server or not.
   * 
   * This flag is switched to true by server sent registration events, and back to false in case of client disconnection or server sent suspension events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MPN device object is currently registered on the server.
   * 
   * - See [getStatus]
   */
  external bool isRegistered();
  /**
   * Checks whether the MPN device object is currently suspended on the server or not.
   * 
   * An MPN device may be suspended if errors occur during push notification delivery.<BR>
   * This flag is switched to true by server sent suspension events, and back to false in case of client disconnection or server sent resume events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MPN device object is currently suspended on the server.
   * 
   * - See [getStatus]
   */
  external bool isSuspended();

  /**
   * Adds a listener that will receive events from the MPN device object.
   * 
   * The same listener can be added to several different MPN device objects.<BR>
   * 
   * **Lifecycle** A listener can be added at any time. A call to add a listener already present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the [MpnDeviceListener] interface.
   * 
   * - See [removeListener]
   */
  void addListener(MpnDeviceListener listener) {
    _addListener(listener._asJSObject);
  }
  /**
   * Removes a listener from the MPN device object so that it will not receive events anymore.
   * 
   * **Lifecycle** A listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(MpnDeviceListener listener) {
    _removeListener(listener._asJSObject);
  }
  /**
   * List containing the [MpnDeviceListener] instances that were added to this MPN device object.
   * 
   * **Returns** a list containing the listeners that were added to this device.
   * 
   * - See [addListener]
   */
  List<MpnDeviceListener> getListeners() {
    return _getListeners().map((obj) => (obj as _MpnDeviceListener)._asDartObject).toList();
  }
}

@JS()
@staticInterop
class _MpnDeviceListener {}

extension _MpnDeviceListenerExt on _MpnDeviceListener {
  external MpnDeviceListener get _asDartObject;
}

/**
 * Interface to be implemented to receive MPN device events including registration, suspension/resume and status change.
 * 
 * Events for these listeners are dispatched by a different thread than the one that generates them. This means that, upon reception of an event,
 * it is possible that the internal state of the client has changed. On the other hand, all the notifications for a single [LightstreamerClient], including
 * notifications to [ClientListener], [SubscriptionListener], [ClientMessageListener], [MpnDeviceListener] and [MpnSubscriptionListener]
 * will be dispatched by the same thread.
 */
@JSExport()
abstract class MpnDeviceListener {
  /**
   * Event handler called when the MpnDeviceListener instance is removed from an MPN device object through [MpnDevice.removeListener].
   * 
   * This is the last event to be fired on the listener.
   */
  void onListenEnd(void dummy) {}
  /**
   * Event handler called when the MpnDeviceListener instance is added to an MPN device object through [MpnDevice.addListener].
   * 
   * This is the first event to be fired on the listener.
   */
  void onListenStart(void dummy) {}
  /**
   * Event handler called when an MPN device object has been successfully registered on the server's MPN Module.
   * 
   * This event handler is always called before other events related to the same device.<BR>
   * Note that this event can be called multiple times in the life of an MPN device object in case the client disconnects and reconnects. In this case
   * the device is registered again automatically.
   */
  void onRegistered() {}
  /**
   * Event handler called when the server notifies an error while registering an MPN device object.
   * 
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [errorCode] The error code sent by the Server. It can be one of the following:<ul>
   * <li>40 - the MPN Module is disabled, either by configuration or by license restrictions.</li>
   * <li>41 - the request failed because of some internal resource error (e.g. database connection, timeout, etc.).</li>
   * <li>43 - invalid or unknown application ID.</li>
   * <li>45 - invalid or unknown MPN device ID.</li>
   * <li>48 - MPN device suspended.</li>
   * <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection.</li>
   * <li>68 - the Server could not fulfill the request because of an internal error.</li>
   * <li>&lt;= 0 - the Metadata Adapter has refused the subscription request; the code value is dependent on the specific Metadata Adapter implementation.</li>
   * </ul>
   * - [errorMessage] The description of the error sent by the Server; it can be null.
   */
  void onRegistrationFailed(int errorCode, String errorMessage) {}
  /**
   * Event handler called when an MPN device object has been resumed on the server's MPN Module.
   * 
   * An MPN device may be resumed from suspended state at the first subsequent registration.<BR>
   * Note that in some server clustering configurations this event may not be called.
   */
  void onResumed() {}
  /**
   * Event handler called when the server notifies that an MPN device changed its status.
   * 
   * Note that in some server clustering configurations the status change for the MPN device suspend event may not be called.
   * 
   * - [status] The new status of the MPN device. It can be one of the following:<ul>
   * <li><code>UNKNOWN</code></li>
   * <li><code>REGISTERED</code></li>
   * <li><code>SUSPENDED</code></li>
   * </ul>
   * - [timestamp] The server-side timestamp of the new device status.
   * 
   * - See [MpnDevice.getStatus]
   * - See [MpnDevice.getStatusTimestamp]
   */
  void onStatusChanged(String status, int timestamp) {}
  /**
   * Event handler called when the server notifies that the list of MPN subscription associated with an MPN device has been updated.
   * 
   * After registration, the list of pre-existing MPN subscriptions for the MPN device is updated and made available through the
   * [LightstreamerClient.getMpnSubscriptions] method.
   * 
   * - See [LightstreamerClient.getMpnSubscriptions]
   */
  void onSubscriptionsUpdated() {}
  /**
   * Event handler called when an MPN device object has been suspended on the server's MPN Module.
   * 
   * An MPN device may be suspended if errors occur during push notification delivery.<BR>
   * Note that in some server clustering configurations this event may not be called.
   */
  void onSuspended() {}

  late final _MpnDeviceListener _that;
  MpnDeviceListener() {
    _that = createDartExport(this) as _MpnDeviceListener;
  }
  _MpnDeviceListener get _asJSObject => _that;
  MpnDeviceListener get _asDartObject => this;
}

/**
 * Class representing a Mobile Push Notifications (MPN) subscription to be submitted to the MPN Module of a Lightstreamer Server.
 * 
 * It contains subscription details and the listener needed to monitor its status. Real-time data is routed via native push notifications.<BR>
 * In order to successfully subscribe an MPN subscription, first an MpnDevice must be created and registered on the LightstreamerClient with
 * [LightstreamerClient.registerForMpn].<BR>
 * After creation, an MpnSubscription object is in the "inactive" state. When an MpnSubscription object is subscribed to on an LightstreamerClient
 * object, through the [LightstreamerClient.subscribe] method, its state switches to "active". This means that the subscription request
 * is being sent to the Lightstreamer Server. Once the server accepted the request, it begins to send real-time events via native push notifications and
 * the MpnSubscription object switches to the "subscribed" state.<BR>
 * If a trigger expression is set, the MPN subscription does not send any push notifications until the expression evaluates to true. When this happens,
 * the MPN subscription switches to "triggered" state and a single push notification is sent. Once triggered, no other push notifications are sent.<BR>
 * When an MpnSubscription is subscribed on the server, it acquires a permanent subscription ID that the server later uses to identify the same
 * MPN subscription on subsequent sessions.<BR>
 * An MpnSubscription can be configured to use either an Item Group or an Item List to specify the items to be subscribed to, and using either a Field Schema
 * or Field List to specify the fields. The same rules that apply to [Subscription] apply to MpnSubscription.<BR>
 * An MpnSubscription object can also be provided by the client to represent a pre-existing MPN subscription on the server. In fact, differently than real-time
 * subscriptions, MPN subscriptions are persisted on the server's MPN Module database and survive the session they were created on.<BR>
 * MPN subscriptions are associated with the MPN device, and after the device has been registered the client retrieves pre-existing MPN subscriptions from the
 * server's database and exposes them with the [LightstreamerClient.getMpnSubscriptions] method.
 */
@JS()
@staticInterop
class MpnSubscription {
  /**
   * Creates an object to be used to describe an MPN subscription that is going to be subscribed to through the MPN Module of Lightstreamer Server.
   * 
   * The object can be supplied to [LightstreamerClient.subscribe] in order to bring the MPN subscription to "active" state.<BR>
   * Note that all of the methods used to describe the subscription to the server can only be called while the instance is in the "inactive" state.
   *
   * - [mode] The subscription mode for the items, required by Lightstreamer Server. Permitted values are:<ul>
   * <li><code>MERGE</code></li>
   * <li><code>DISTINCT</code></li>
   * </ul>
   * - [items] An array of items to be subscribed to through Lightstreamer Server. It is also possible specify the "Item List" or
   * "Item Group" later through [MpnSubscription.setItems] and [setItemGroup].
   * - [fields] An array of fields for the items to be subscribed to through Lightstreamer Server. It is also possible to specify the "Field List" or
   * "Field Schema" later through [MpnSubscription.setFields] and [setFieldSchema].
   * 
   * **Throws** IllegalArgumentException If no or invalid subscription mode is passed.
   * 
   * **Throws** IllegalArgumentException If either the items or the fields array is left null.
   * 
   * **Throws** IllegalArgumentException If the specified "Item List" or "Field List" is not valid; see [MpnSubscription.setItems] and [MpnSubscription.setFields] for details.
   */
  external factory MpnSubscription(String mode, [List<String>? items, List<String>? fields]);
}

extension MpnSubscriptionExt on MpnSubscription {
  @JS('addListener') external void _addListener(_MpnSubscriptionListener listener);
  @JS('getListeners') external List<dynamic> _getListeners();
  @JS('removeListener') external void _removeListener(_MpnSubscriptionListener listener);
  /**
   * Inquiry method that can be used to read the name of the Data Adapter specified for this 
   * MpnSubscription through [setDataAdapter].
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the name of the Data Adapter; returns null if no name has been configured, 
   * so that the "DEFAULT" Adapter Set is used.
   */
  external String? getDataAdapter();
  /**
   * Setter method that sets the name of the Data Adapter
   * (within the Adapter Set used by the current session)
   * that supplies all the items for this MpnSubscription.
   * 
   * The Data Adapter name is configured on the server side through
   * the "name" attribute of the "data_provider" element, in the
   * "adapters.xml" file that defines the Adapter Set (a missing attribute
   * configures the "DEFAULT" name). <BR>
   * Note that if more than one Data Adapter is needed to supply all the
   * items in a set of items, then it is not possible to group all the
   * items of the set in a single MpnSubscription. Multiple MpnSubscriptions
   * have to be defined.
   *
   * **Default** The default Data Adapter for the Adapter Set,
   * configured as "DEFAULT" on the Server.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>adapter</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [dataAdapter] the name of the Data Adapter. A null value 
   * is equivalent to the "DEFAULT" name.
   * 
   * **Throws** IllegalStateException if the Subscription is currently 
   * "active".
   *
   * - See [ConnectionDetails.setAdapterSet]
   */
  external void setDataAdapter(String? dataAdapter);
  @JS('getFields') external List<dynamic>? _getFields();
  /**
   * Setter method that sets the "Field List" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>schema</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [fields] an array of fields to be subscribed to through the server. 
   * 
   * **Throws** IllegalArgumentException if any of the field names in the list
   * contains a space or is empty/null.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  external void setFields(List<String>? fields);
  /**
   * Inquiry method that can be used to read the field schema specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * fields are always expressed with a "Field Schema"", even if originally the MPN subscription used a "Field List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized 
   * using a "Field Schema"
   * 
   * **Returns** the "Field Schema" to be subscribed to through the server, or null if the MpnSubscription was initialized with a "Field List" or was not initialized at all.
   */
  external String? getFieldSchema();
  /**
   * Setter method that sets the "Field Schema" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Field List" or "Field Schema"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>schema</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [schemaName] A String to be expanded into a field list by the
   * Metadata Adapter. 
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  external void setFieldSchema(String? schemaName);
  /**
   * Inquiry method that can be used to read the item group specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * items are always expressed with an "Item Group"", even if originally the MPN subscription used an "Item List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized
   * using an "Item Group"
   * 
   * **Returns** the "Item Group" to be subscribed to through the server, or null if the MpnSubscription was initialized with an "Item List" or was not initialized at all.
   */
  external String? getItemGroup();
  /**
   * Setter method that sets the "Item Group" to be subscribed to through 
   * Lightstreamer Server.
   * 
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>group</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [groupName] A String to be expanded into an item list by the
   * Metadata Adapter. 
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  external void setItemGroup(String? groupName);
  @JS('getItems') external List<dynamic>? _getItems();
  /**
   * Setter method that sets the "Item List" to be subscribed to through 
   * Lightstreamer Server. 
   * 
   * Any call to this method will override any "Item List" or "Item Group"
   * previously specified.
   * 
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>group</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [items] an array of items to be subscribed to through the server. 
   * 
   * **Throws** IllegalArgumentException if any of the item names in the "Item List"
   * contains a space or is a number or is empty/null.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   */
  external void setItems(List<String>? items);
  /**
   * Inquiry method that can be used to read the mode specified for this
   * MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MpnSubscription mode specified in the constructor.
   */
  external String getMode();
  /**
   * Inquiry method that can be used to read the buffer size, configured though
   * [setRequestedBufferSize], to be requested to the Server for 
   * this MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  An integer number, representing the buffer size to be requested to the server,
   * or the string "unlimited", or null.
   */
  external String? getRequestedBufferSize();
  /**
   * Setter method that sets the length to be requested to Lightstreamer
   * Server for the internal queuing buffers for the items in the MpnSubscription.
   * 
   * A Queuing buffer is used by the Server to accumulate a burst
   * of updates for an item, so that they can all be sent to the client,
   * despite of bandwidth or frequency limits.<BR>
   * Note that the Server may pose an upper limit on the size of its internal buffers.
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This means that the buffer size will be 1 for MERGE 
   * subscriptions and "unlimited" for DISTINCT subscriptions. See 
   * the "General Concepts" document for further details.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>requested_buffer_size</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [size]  An integer number, representing the length of the internal queuing buffers
   * to be used in the Server. If the string "unlimited" is supplied, then no buffer
   * size limit is requested (the check is case insensitive). It is also possible
   * to supply a null value to stick to the Server default (which currently
   * depends on the subscription mode).
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor "unlimited" nor a valid positive integer number.
   *
   * - See [setRequestedMaxFrequency]
   */
  external void setRequestedBufferSize(String? size);
  /**
   * Inquiry method that can be used to read the max frequency, configured
   * through [setRequestedMaxFrequency], to be requested to the 
   * Server for this MpnSubscription.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns**  A decimal number, representing the max frequency to be requested to the server
   * (expressed in updates per second), or the string "unlimited", or null.
   */
  external String? getRequestedMaxFrequency();
  /**
   * Setter method that sets the maximum update frequency to be requested to
   * Lightstreamer Server for all the items in the MpnSubscription.
   * 
   * Note that frequency limits on the items can also be set on the
   * server side and this request can only be issued in order to further
   * reduce the frequency, not to rise it beyond these limits.
   *
   * **General Edition Note** A further global frequency limit could also be imposed by the Server,
   * depending on Edition and License Type.
   * To know what features are enabled by your license, please see the License tab of the
   * Monitoring Dashboard (by default, available at /dashboard).
   *
   * **Default** null, meaning to lean on the Server default based on the subscription
   * mode. This consists, for all modes, in not applying any frequency 
   * limit to the subscription (the same as "unlimited"); see the "General Concepts"
   * document for further details.
   *
   * **Lifecycle** This method can only be called while the MpnSubscription
   * instance is in its "inactive" state.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>requested_max_frequency</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [freq]  A decimal number, representing the maximum update frequency (expressed in updates
   * per second) for each item in the Subscription; for instance, with a setting
   * of 0.5, for each single item, no more than one update every 2 seconds
   * will be received. If the string "unlimited" is supplied, then no frequency
   * limit is requested. It is also possible to supply the null value to stick 
   * to the Server default (which currently corresponds to "unlimited").
   * The check for the string constants is case insensitive.
   * 
   * **Throws** IllegalStateException if the MpnSubscription is currently 
   * "active".
   * 
   * **Throws** IllegalArgumentException if the specified value is not
   * null nor the special "unlimited" value nor a valid positive number.
   */
  external void setRequestedMaxFrequency(String? freq);
  /**
   * Checks if the MpnSubscription is currently "active" or not.
   * 
   * Most of the MpnSubscription properties cannot be modified if an MpnSubscription is "active".<BR>
   * The status of an MpnSubscription is changed to "active" through the [LightstreamerClient.subscribe] method and back to "inactive"
   * through the [LightstreamerClient.unsubscribe] and [LightstreamerClient.unsubscribeMpnSubscriptions] ones.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription is currently "active", false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  external bool isActive();
  /**
   * Checks if the MpnSubscription is currently subscribed to through the server or not.
   * 
   * This flag is switched to true by server sent subscription events, and back to false in case of client disconnection,
   * [LightstreamerClient.unsubscribe] or [LightstreamerClient.unsubscribeMpnSubscriptions] calls, and server sent 
   * unsubscription events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription has been successfully subscribed on the server, false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  external bool isSubscribed();
  /**
   * Checks if the MpnSubscription is currently triggered or not.
   * 
   * This flag is switched to true when a trigger expression has been set and it evaluated to true at least once. For this to happen, the subscription
   * must already be in "active" and "subscribed" states. It is switched back to false if the subscription is modified with a
   * [LightstreamerClient.subscribe] call on a copy of it, deleted with [LightstreamerClient.unsubscribe] or
   * [LightstreamerClient.unsubscribeMpnSubscriptions] calls, and server sent subscription events.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** true if the MpnSubscription's trigger expression has been evaluated to true at least once, false otherwise.
   * 
   * - See [getStatus]
   * - See [LightstreamerClient.subscribe]
   * - See [LightstreamerClient.unsubscribe]
   * - See [LightstreamerClient.unsubscribeMpnSubscriptions]
   */
  external bool isTriggered();

  /**
   * Inquiry method that gets the JSON structure used by the Sever to send notifications.
   *
   * **Returns** the JSON structure used by the Server to send notifications or null if the value is not available.
   *
   * - See [getNotificationFormat]
   */
  external String? getActualNotificationFormat();
  /**
   * Inquiry method that gets the trigger expression evaluated by the Sever.
   *
   * **Returns** returns the trigger sent by the Server or null if the value is not available.
   *
   * - See [getTriggerExpression]
   */
  external String? getActualTriggerExpression();
  /**
   * Sets the boolean expression that will be evaluated against each update and will act as a trigger to deliver the push notification.
   * 
   * If a trigger expression is set, the MPN subscription does not send any push notifications until the expression evaluates to true. When this happens,
   * the MPN subscription "triggers" and a single push notification is sent. Once triggered, no other push notifications are sent. In other words, with a trigger
   * expression set, the MPN subscription sends *at most one* push notification.<BR>
   * The expression must be in Java syntax and can contain named arguments with the format <code>${field}</code>, or indexed arguments with the format `$[1]`.
   * The same rules that apply to [setNotificationFormat] apply also to the trigger expression. The expression is verified and evaluated on the server.<BR>
   * Named and indexed arguments are replaced by the server with the value of corresponding subscription fields before the expression is evaluated. They are
   * represented as String variables, and as such appropriate type conversion must be considered. E.g.<ul>
   * <li><code>Double.parseDouble(${last_price}) &gt; 500.0</code></li>
   * </ul>
   * Argument variables are named with the prefix <code>LS_MPN_field</code> followed by an index. Thus, variable names like <code>LS_MPN_field1</code> should be considered
   * reserved and their use avoided in the expression.<BR>
   * Consider potential impact on server performance when writing trigger expressions. Since Java code may use classes and methods of the JDK, a badly written
   * trigger may cause CPU hogging or memory exhaustion. For this reason, a server-side filter may be applied to refuse poorly written (or even
   * maliciously crafted) trigger expressions. See the "General Concepts" document for more information.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * named arguments are always mapped to its corresponding indexed argument, even if originally the trigger expression used a named argument.<BR>
   * Note: the content of this property may be subject to length restrictions (See the "General Concepts" document for more information).
   * 
   * **Lifecycle** This property can be changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>trigger</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [trigger] the boolean expression that acts as a trigger to deliver the push notification. If the value is null, no trigger is set on the subscription.
   * 
   * - See [isTriggered]
   */
  external void setTriggerExpression(String? trigger);
  /**
   * Inquiry method that gets the JSON structure requested by the user to be used as the format of push notifications.
   * 
   * **Returns** the JSON structure requested by the user to be used as the format of push notifications.
   * 
   * - See [setNotificationFormat]
   * - See [getActualNotificationFormat]
   */
  external String? getNotificationFormat();
  /**
   * Sets the JSON structure to be used as the format of push notifications.
   * 
   * This JSON structure is sent by the server to the push notification service provider (i.e. Google's FCM), hence it must follow
   * its specifications.<BR>
   * The JSON structure may contain named arguments with the format <code>${field}</code>, or indexed arguments with the format `$[1]`. These arguments are 
   * replaced by the server with the value of corresponding subscription fields before the push notification is sent.<BR>
   * For instance, if the subscription contains fields "stock_name" and "last_price", the notification format could be something like this:<ul>
   * <li><code>{ "android" : { "notification" : { "body" : "Stock ${stock_name} is now valued ${last_price}" } } }</code></li>
   * </ul>
   * Named arguments are available if the Metadata Adapter is a subclass of LiteralBasedProvider or provides equivalent functionality, otherwise only
   * indexed arguments may be used. In both cases common metadata rules apply: field names and indexes are checked against the Metadata Adapter, hence
   * they must be consistent with the schema and group specified.<BR>
   * A special server-managed argument may also be used:<ul>
   * <li><code>${LS_MPN_subscription_ID}</code>: the ID of the MPN subscription generating the push notification.
   * </ul>
   * The MpnBuilder object provides methods to build an appropriate JSON structure from its defining fields.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * named arguments are always mapped to its corresponding indexed argument, even if originally the notification format used a named argument.<BR>
   * Note: the content of this property may be subject to length restrictions (See the "General Concepts" document for more information).
   * 
   * **Lifecycle** This property can be changed at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>notification_format</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * - [format] the JSON structure to be used as the format of push notifications.
   * 
   * - See [FirebaseMpnBuilder]
   * - See [ApnsMpnBuilder]
   */
  external void setNotificationFormat(String format);
  /**
   * The status of the subscription.
   * 
   * The status can be:<ul>
   * <li><code>UNKNOWN</code>: when the MPN subscription has just been created or deleted (i.e. unsubscribed). In this status [isActive], [isSubscribed] 
   * and [isTriggered] are all false.</li>
   * <li><code>ACTIVE</code>: when the MPN susbcription has been submitted to the server, but no confirm has been received yet. In this status [isActive] is true, 
   * [isSubscribed] and [isTriggered] are false.</li>
   * <li><code>SUBSCRIBED</code>: when the MPN subscription has been successfully subscribed on the server. If a trigger expression is set, it has not been
   * evaluated to true yet. In this status [isActive] and [isSubscribed] are true, [isTriggered] is false.</li>
   * <li><code>TRIGGERED</code>: when the MPN subscription has a trigger expression set, has been successfully subscribed on the server and
   * the trigger expression has been evaluated to true at least once. In this status [isActive], [isSubscribed] and [isTriggered] are all true.</li>
   * </ul>
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the status of the subscription.
   * 
   * - See [isActive]
   * - See [isSubscribed]
   * - See [isTriggered]
   */
  external String getStatus();
  /**
   * The server-side timestamp of the subscription status.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Notification** A change to this setting will be notified through a call to [MpnSubscriptionListener.onPropertyChanged]
   * with argument <code>status_timestamp</code> on any [MpnSubscriptionListener] listening to the related MpnSubscription.
   * 
   * **Returns** The server-side timestamp of the subscription status.
   * 
   * - See [getStatus]
   */
  external int getStatusTimestamp();
  /**
   * The server-side unique persistent ID of the MPN subscription.
   * 
   * The ID is available only after the MPN subscription has been successfully subscribed on the server. I.e. when its status is <code>SUBSCRIBED</code> or
   * <code>TRIGGERED</code>.<BR>
   * Note: more than one MpnSubscription may exists at any given time referring to the same MPN subscription, and thus with the same subscription ID.
   * For instance, copying an MpnSubscription with the copy initializer creates a second MpnSubscription instance with the same subscription ID. Also,
   * the <code>coalescing</code> flag of [LightstreamerClient.subscribe] may cause the assignment of a pre-existing MPN subscription ID 
   * to the new subscription.<BR>
   * Two MpnSubscription objects with the same subscription ID always represent the same server-side MPN subscription. It is the client's duty to keep the status
   * and properties of these objects up to date and aligned.
   * 
   * **Lifecycle** This method can be called at any time.
   * 
   * **Returns** the MPN subscription ID.
   */
  external String? getSubscriptionId();
  /**
   * Inquiry method that gets the trigger expression requested by the user.
   * 
   * **Returns** returns the trigger requested by the user or null if the value is not available.
   * 
   * - See [setTriggerExpression]
   * - See [getActualTriggerExpression]
   */
  external String? getTriggerExpression();

  /**
   * Adds a listener that will receive events from the MpnSubscription instance.
   * 
   * The same listener can be added to several different MpnSubscription instances.<BR>
   * 
   * **Lifecycle** A listener can be added at any time. A call to add a listener already present will be ignored.
   * 
   * - [listener] An object that will receive the events as documented in the [MpnSubscriptionListener]  interface.
   * 
   * - See [removeListener]
   */
  void addListener(MpnSubscriptionListener listener) {
    _addListener(listener._asJSObject);
  }
  /**
   * Removes a listener from the MpnSubscription instance so that it will not receive events anymore.
   * 
   * **Lifecycle** A listener can be removed at any time.
   * 
   * - [listener] The listener to be removed.
   * 
   * - See [addListener]
   */
  void removeListener(MpnSubscriptionListener listener) {
    _removeListener(listener._asJSObject);
  }
  /**
   * Returns the list containing the [MpnSubscriptionListener] instances that were added to this MpnSubscription.
   * 
   * **Returns** a list containing the listeners that were added to this subscription.
   *
   * - See [addListener]
   */
  List<MpnSubscriptionListener> getListeners() {
    return _getListeners().map((obj) => (obj as _MpnSubscriptionListener)._asDartObject).toList();
  }
  /**
   * Inquiry method that can be used to read the "Field List" specified for this MpnSubscription.
   * 
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * fields are always expressed with a "Field Schema"", even if originally the MPN subscription used a "Field List".
   *
   * **Lifecycle**  This method can only be called if the MpnSubscription has been initialized 
   * using a "Field List".
   * 
   * **Returns** the "Field List" to be subscribed to through the server, or null if the MpnSubscription was initialized with a "Field Schema" or was not initialized at all.
   */
  List<String>? getFields() {
    return _getFields()?.cast<String>();
  }
  /**
   * Inquiry method that can be used to read the "Item List" specified for this MpnSubscription.
   * 
   * Note that if the single-item-constructor was used, this method will return an array 
   * of length 1 containing such item.<BR>
   * Note: if the MpnSubscription has been created by the client, such as when obtained through [LightstreamerClient.getMpnSubscriptions],
   * items are always expressed with an "Item Group"", even if originally the MPN subscription used an "Item List".
   *
   * **Lifecycle** This method can only be called if the MpnSubscription has been initialized 
   * with an "Item List".
   * 
   * **Returns** the "Item List" to be subscribed to through the server, or null if the MpnSubscription was initialized with an "Item Group" or was not initialized at all.
   */
  List<String>? getItems() {
    return _getItems()?.cast<String>();
  }
}

@JS()
@staticInterop
class _MpnSubscriptionListener {}

extension _MpnSubscriptionListenerExt on _MpnSubscriptionListener {
  external MpnSubscriptionListener get _asDartObject;
}

/**
 * Interface to be implemented to receive [MpnSubscription] events including subscription/unsubscription, triggering and status change.
 * 
 * Events for these listeners are dispatched by a different thread than the one that generates them. This means that, upon reception of an event,
 * it is possible that the internal state of the client has changed. On the other hand, all the notifications for a single [LightstreamerClient], including
 * notifications to [ClientListener], [SubscriptionListener], [ClientMessageListener], [MpnDeviceListener] and MpnSubscriptionListener
 * will be dispatched by the same thread.
 */
@JSExport()
abstract class MpnSubscriptionListener {
  /**
   * Event handler called when the MpnSubscriptionListener instance is removed from an [MpnSubscription] through 
   * [MpnSubscription.removeListener].
   * 
   * This is the last event to be fired on the listener.
   */
  void onListenEnd(void dummy) {}
  /**
   * Event handler called when the MpnSubscriptionListener instance is added to an [MpnSubscription] through 
   * [MpnSubscription.addListener].
   * 
   * This is the first event to be fired on the listener.
   */
  void onListenStart(void dummy) {}
  /**
   * Event handler called when the value of a property of [MpnSubscription] cannot be changed.
   * 
   * Properties can be modified by direct calls to their setters. See [MpnSubscription.setNotificationFormat] and [MpnSubscription.setTriggerExpression].
   * 
   * - [errorCode] The error code sent by the Server.
   * - [errorMessage] The description of the error sent by the Server.
   * - [propertyName] The name of the changed property. It can be one of the following:<ul>
   * <li><code>notification_format</code></li>
   * <li><code>trigger</code></li>
   * </ul>
   */
  void onModificationError(int errorCode, String errorMessage, String propertyName) {}
  /**
   * Event handler called each time the value of a property of [MpnSubscription] is changed.
   * 
   * Properties can be modified by direct calls to their setter or by server sent events. A property may be changed by a server sent event when the MPN subscription is
   * modified, or when two MPN subscriptions coalesce (see [LightstreamerClient.subscribeMpn]).
   * 
   * - [propertyName] The name of the changed property. It can be one of the following:<ul>
   * <li><code>mode</code></li>
   * <li><code>group</code></li>
   * <li><code>schema</code></li>
   * <li><code>adapter</code></li>
   * <li><code>notification_format</code></li>
   * <li><code>trigger</code></li>
   * <li><code>requested_buffer_size</code></li>
   * <li><code>requested_max_frequency</code></li>
   * <li><code>status_timestamp</code></li>
   * </ul>
   */
  void onPropertyChanged(String propertyName) {}
  /**
   * Event handler called when the server notifies that an [MpnSubscription] changed its status.
   * 
   * Note that in some server clustering configurations the status change for the MPN subscription's trigger event may not be called. The corresponding push
   * notification is always sent, though.
   * 
   * - [status] The new status of the MPN subscription. It can be one of the following:<ul>
   * <li><code>UNKNOWN</code></li>
   * <li><code>ACTIVE</code></li>
   * <li><code>SUBSCRIBED</code></li>
   * <li><code>TRIGGERED</code></li>
   * </ul>
   * - [timestamp] The server-side timestamp of the new subscription status.
   * 
   * - See [MpnSubscription.getStatus]
   * - See [MpnSubscription.getStatusTimestamp]
   */
  void onStatusChanged(String status, int timestamp) {}
  /**
   * Event handler called when an [MpnSubscription] has been successfully subscribed to on the server's MPN Module.
   * 
   * This event handler is always called before other events related to the same subscription.<BR>
   * Note that this event can be called multiple times in the life of an MpnSubscription instance only in case it is subscribed multiple times
   * through [LightstreamerClient.unsubscribeMpn] and [LightstreamerClient.subscribeMpn]. Two consecutive calls 
   * to this method are not possible, as before a second <code>onSubscription()</code> event an [onUnsubscription] event is always fired.
   */
  void onSubscription() {}
  /**
   * Event handler called when the server notifies an error while subscribing to an [MpnSubscription].
   * 
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [errorCode] The error code sent by the Server. It can be one of the following:<ul>
   * <li>17 - bad Data Adapter name or default Data Adapter not defined for the current Adapter Set.</li>
   * <li>21 - bad Group name.</li>
   * <li>22 - bad Group name for this Schema.</li>
   * <li>23 - bad Schema name.</li>
   * <li>24 - mode not allowed for an Item.</li>
   * <li>30 - subscriptions are not allowed by the current license terms (for special licenses only).</li>
   * <li>40 - the MPN Module is disabled, either by configuration or by license restrictions.</li>
   * <li>41 - the request failed because of some internal resource error (e.g. database connection, timeout, etc.).</li>
   * <li>43 - invalid or unknown application ID.</li>
   * <li>44 - invalid syntax in trigger expression.</li>
   * <li>45 - invalid or unknown MPN device ID.</li>
   * <li>46 - invalid or unknown MPN subscription ID (for MPN subscription modifications).</li>
   * <li>47 - invalid argument name in notification format or trigger expression.</li>
   * <li>48 - MPN device suspended.</li>
   * <li>49 - one or more subscription properties exceed maximum size.</li>
   * <li>50 - no items or fields have been specified.</li>
   * <li>52 - the notification format is not a valid JSON structure.</li>
   * <li>53 - the notification format is empty.</li>
   * <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection.</li>
   * <li>68 - the Server could not fulfill the request because of an internal error.</li>
   * <li>&lt;= 0 - the Metadata Adapter has refused the subscription request; the code value is dependent on the specific Metadata Adapter implementation.</li>
   * </ul>
   * - [errorMessage] The description of the error sent by the Server; it can be null.
   */
  void onSubscriptionError(int errorCode, String errorMessage) {}
  /**
   * Event handler called when the server notifies that an [MpnSubscription] did trigger.
   * 
   * For this event to be called the MpnSubscription must have a trigger expression set and it must have been evaluated to true at
   * least once.<BR>
   * Note that this event can be called multiple times in the life of an MpnSubscription instance only in case it is subscribed multiple times
   * through [LightstreamerClient.unsubscribeMpn] and [LightstreamerClient.subscribeMpn]. Two consecutive calls 
   * to this method are not possible.<BR>
   * Note also that in some server clustering configurations this event may not be called. The corresponding push notification is always sent, though.
   * 
   * - See [MpnSubscription.setTriggerExpression]
   */
  void onTriggered() {}
  /**
   * Event handler called when an [MpnSubscription] has been successfully unsubscribed from on the server's MPN Module.
   * 
   * After this call no more events can be received until a new [onSubscription] event.<BR>
   * Note that this event can be called multiple times in the life of an MpnSubscription instance only in case it is subscribed multiple times
   * through [LightstreamerClient.unsubscribeMpn] and [LightstreamerClient.subscribeMpn]. Two consecutive calls 
   * to this method are not possible, as before a second [onUnsubscription] event an [onSubscription] event is always fired.
   */
  void onUnsubscription() {}
  /**
   * Event handler called when the server notifies an error while unsubscribing from an [MpnSubscription].
   * 
   * By implementing this method it is possible to perform recovery actions.
   * 
   * - [errorCode] The error code sent by the Server. It can be one of the following:<ul>
   * <li>30 - subscriptions are not allowed by the current license terms (for special licenses only).</li>
   * <li>40 - the MPN Module is disabled, either by configuration or by license restrictions.</li>
   * <li>41 - the request failed because of some internal resource error (e.g. database connection, timeout, etc.).</li>
   * <li>43 - invalid or unknown application ID.</li>
   * <li>45 - invalid or unknown MPN device ID.</li>
   * <li>46 - invalid or unknown MPN subscription ID.</li>
   * <li>48 - MPN device suspended.</li>
   * <li>66 - an unexpected exception was thrown by the Metadata Adapter while authorizing the connection.</li>
   * <li>68 - the Server could not fulfill the request because of an internal error.</li>
   * <li>&lt;= 0 - the Metadata Adapter has refused the unsubscription request; the code value is dependent on the specific Metadata Adapter implementation.</li>
   * </ul>
   * - [errorMessage] The description of the error sent by the Server; it can be null.
   */
  void onUnsubscriptionError(int errorCode, String errorMessage) {}

  late final _MpnSubscriptionListener _that;
  MpnSubscriptionListener() {
    _that = createDartExport(this) as _MpnSubscriptionListener;
  }
  _MpnSubscriptionListener get _asJSObject => _that;
  MpnSubscriptionListener get _asDartObject => this;
}

/**
 * Utility class that provides methods to build or parse the JSON structure used to represent the format of a push notification.
 * 
 * It provides getters and setters for the fields of a push notification, 
 * following the format specified by <a href="https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages">FCM REST API</a>.
 * This format is compatible with [MpnSubscription.setNotificationFormat].
 *
 * - See [MpnSubscription.setNotificationFormat]
 */
@JS()
@staticInterop
class FirebaseMpnBuilder {
  /**
   * Creates an object to be used to create a push notification format.
   * 
   * Use setters methods to set the value of push notification fields or use a JSON structure to initialize the fields.
   *
   * - [notificationFormat] A JSON structure representing a push notification format.
   */
  external factory FirebaseMpnBuilder([String? notificationFormat]);
}

extension FirebaseMpnBuilderExt on FirebaseMpnBuilder {
  /**
   * Produces the JSON structure for the push notification format specified by this object.
   * 
   * **Returns** the JSON structure for the push notification format.
   */
  external String build();
  /**
   * Gets the value of <code>webpush&period;notification&period;body</code> field.
   * 
   * **Returns** the value of <code>webpush&period;notification&period;body</code> field, or null if absent.
   */
  external String? getBody();
  @JS('getData') external Object? _getData();
  @JS('getHeaders') external Object? _getHeaders();
  /**
   * Gets the value of <code>webpush&period;notification&period;icon</code> field.
   * 
   * **Returns** the value of <code>webpush&period;notification&period;icon</code> field, or null if absent.
   */
  external String? getIcon();
  /**
   * Gets the value of <code>webpush&period;notification&period;title</code> field.
   * 
   * **Returns** the value of <code>webpush&period;notification&period;title</code> field, or null if absent.
   */
  external String? getTitle();
  /**
   * Sets the <code>webpush&period;notification&period;body</code> field.
   *
   * - [body] A string to be used for the <code>webpush&period;notification&period;body</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external FirebaseMpnBuilder setBody(String? body);
  @JS('setData') external FirebaseMpnBuilder _setData(Object? data);
  @JS('setHeaders') external FirebaseMpnBuilder _setHeaders(Object? headers);
  /**
   * Sets the <code>webpush&period;notification&period;icon</code> field.
   *
   * - [icon] A string to be used for the <code>webpush&period;notification&period;icon</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external FirebaseMpnBuilder setIcon(String? icon);
  /**
   * Sets the <code>webpush&period;notification&period;title</code> field.
   *
   * - [title] A string to be used for the <code>webpush&period;notification&period;title</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external FirebaseMpnBuilder setTitle(String? title);

  /**
   * Gets sub-fields of the <code>webpush&period;data</code> field.
   * 
   * **Returns** a map with sub-fields of the <code>webpush&period;data</code> field, or null if absent.
   */
  Map<String, String>? getData() {
    return (dartify(_getData()) as Map<dynamic, dynamic>).cast<String, String>();
  }
  /**
   * Sets sub-fields of the <code>webpush&period;data</code> field.
   *
   * - [data] A map to be used for sub-fields of the <code>webpush&period;data</code> field, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  FirebaseMpnBuilder setData(Map<String, String>? data) {
    return _setData(jsify(data));
  }
  /**
   * Gets sub-fields of the <code>webpush&period;headers</code> field.
   * 
   * **Returns** a map with sub-fields of the <code>webpush&period;headers</code> field, or null if absent.
   */
  Map<String, String>? getHeaders() {
    return (dartify(_getHeaders()) as Map<dynamic, dynamic>).cast<String, String>();
  }
  /**
   * Sets sub-fields of the <code>webpush&period;headers</code> field.
   *
   * - [headers] map to be used for sub-fields of the <code>webpush&period;headers</code> field, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  FirebaseMpnBuilder setHeaders(Map<String, String>? headers) {
    return _setHeaders(jsify(headers));
  }
}

/**
 * Utility class that provides methods to build or parse the JSON structure used to represent the format of a push notification.
 * 
 * It provides getters and setters for the fields of a push notification, following the format specified by Apple Push Notification Service (APNs).
 * This format is compatible with [MpnSubscription.setNotificationFormat].
 *
 * - See [MpnSubscription.setNotificationFormat]
 */
@JS()
@staticInterop
class SafariMpnBuilder {
  /**
   * Creates an object to be used to create a push notification format.
   * 
   * Use setters methods to set the value of push notification fields or use a JSON structure to initialize the fields.
   * 
   * - [notificationFormat] A JSON structure representing a push notification format.
   */
  external factory SafariMpnBuilder([String? notificationFormat]);
}

extension SafariMpnBuilderExt on SafariMpnBuilder {
  /**
   * Produces the JSON structure for the push notification format specified by this object.
   * 
   * **Returns** the JSON structure for the push notification format.
   */
  external String build();
  /**
   * Gets the value of <code>aps&period;alert&period;action</code> field.
   * 
   * **Returns** the value of <code>aps&period;alert&period;action</code> field, or null if absent.
   */
  external String? getAction();
  /**
   * Gets the value of <code>aps&period;alert&period;body</code> field.
   * 
   * **Returns** the value of <code>aps&period;alert&period;body</code> field, or null if absent.
   */
  external String? getBody();
  /**
   * Gets the value of <code>aps&period;alert&period;title</code> field.
   * 
   * **Returns** the value of <code>aps&period;alert&period;title</code> field, or null if absent.
   */
  external String? getTitle();
  @JS('getUrlArguments') external List<dynamic>? _getUrlArguments();
  /**
   * Sets the <code>aps&period;alert&period;action</code> field.
   *
   * - [action] A string to be used for the <code>aps&period;alert&period;action</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external SafariMpnBuilder setAction(String? action);
  /**
   * Sets the <code>aps&period;alert&period;body</code> field.
   *
   * - [body] A string to be used for the <code>aps&period;alert&period;body</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external SafariMpnBuilder setBody(String? body);
  /**
   * Sets the <code>aps&period;alert&period;title</code> field.
   *
   * - [title] A string to be used for the <code>aps&period;alert&period;title</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external SafariMpnBuilder setTitle(String? title);
  /**
   * Sets the <code>aps&period;url-args</code> field.
   *
   * - [urlArguments] An array to be used for the <code>aps&period;url-args</code> field value, or null to clear it.
   * 
   * **Returns** this MpnBuilder object, for fluent use.
   */
  external SafariMpnBuilder setUrlArguments(List<String>? urlArguments);

  /**
   * Gets the value of <code>aps&period;url-args</code> field.
   * 
   * **Returns** the value of <code>aps&period;url-args</code> field, or null if absent.
   */
  List<String>? getUrlArguments() {
    return _getUrlArguments()?.cast<String>();
  }
}
